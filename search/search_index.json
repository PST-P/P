{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } Modular and Safe Programming for Distributed Systems P is a state machine based programming language for modeling and specifying complex distributed systems. P allows programmers to model their system as a collection of communicating state machines. P supports several backend analysis engines (based on automated reasoning techniques like model checking and symbolic execution) to check that the distributed system modeled in P satisfy the desired correctness specifications. Not only can a P program be systematically tested (e.g., model checking), but it can also be compiled into executable code. Essentially, P unifies modeling, specifying, implementing, and testing into one activity for the programmer. P is currently being used extensively inside Amazon (AWS) for analysis of complex distributed systems. P is also being used for programming safe robotics systems. P was first used to implement and validate the USB device driver stack that ships with Microsoft Windows 8 and Windows Phone. Programming concurrent, asynchronous distributed systems is challenging, but a pinch of programming language design combined with a dash of automated reasoning can go a long way in bringing the joy back. Let the fun begin! You can find most of the information about the P framework on this webpage: what is P? , getting started , tutorials , case studies and related research publications . If you have any further questions, please feel free to create an issue , ask on discussions , or email us Contributions P has always been a collaborative project between industry and academia (since 2013) . The P team welcomes contributions and suggestions from all of you!! .","title":"Home"},{"location":"#let-the-fun-begin","text":"You can find most of the information about the P framework on this webpage: what is P? , getting started , tutorials , case studies and related research publications . If you have any further questions, please feel free to create an issue , ask on discussions , or email us Contributions P has always been a collaborative project between industry and academia (since 2013) . The P team welcomes contributions and suggestions from all of you!! .","title":"Let the fun begin!"},{"location":"casestudies/","text":"[AWS] Amazon S3 Strong Consistency In Dec 2020, Amazon S3 launched Strong Consistency with guaranteed strong read-after-write consistency . The S3 team used automated reasoning for ensuring the correctness of S3's Strong Consistency design. Werner had a detailed blog post about the challenges involved. Qoute from Werners blog: Diving Deep on S3 Consistency Common testing techniques like unit testing and integration testing are valuable, necessary tools in any production system. But they aren\u2019t enough when you need to build a system with such a high bar for correctness. We want a system that\u2019s \u201cprovably correct\u201d, not just \u201cprobably correct.\u201d So, for strong consistency, we utilized a variety of techniques for ensuring that what we built is correct, and continues to be correct as the system evolves. We employed integration tests, deductive proofs of our proposed cache coherence algorithm, model checking to formalize our consistency design and to demonstrate its correctness, and we expanded on our model checking to examine actual runnable code. P was used for creating formal models of all the core distributed protocols involved in S3's strong consistency and model checking that the system satisfies the desired correctness guarantees. Details about P and how it is being used by the S3 team can be found in the AWS Pi-Week Talk on Use of Automated Reasoning for S3 Strong Consistency Launch . [AWS] Amazon IoT Devices: OTA Protocol AWS FreeRTOS is a real-time operating system designed to run on IoT devices to enable them to interact easily and reliably with AWS services. The Over the Air (OTA) update functionality makes it possible to update a device with security fixes quickly and reliably. The OTA Library , a part of the overall OTA functionality that runs on the IoT devices, enables customers to learn of available updates, download the updates, check their cryptographic signatures, and apply them. The OTA system is a complex piece of software that performs firmware updates reliably and securely --- keeping all devices in a consistent state --- in the presence of arbitrary failures of devices and communication. The heart of the OTA system is an intricate distributed protocol, the OTA protocol, that co-ordinates the execution of the different agents involved. P was used for creating formal models of the OTA protocol and model checking its correctness. During this process the team found 3 bugs in the model that pointed to potential issues in the actual implementation itself. Related Blog: Using Formal Methods to validate OTA Protocol [UC Berkeley] Programming Safe Robotics Systems DRONA is a software framework for programming safe distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the correctness of robotics software stack. The C code generated from P compiler can be deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/ See the fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram. [UC Berkeley] Programming Secure Distributed Systems Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. PSec framework extended the P language to enable programming secure distributed systems. PSec leverages Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, PSec prevents programmers from inadvertently leaking sensitive information while sending data securely across machines. PSec was used to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here . [Microsoft] Windows USB 3.0 Device Drivers Event-driven asynchronous programs typically have layers of design, where the higher layers reason with how the various components (or machines) interact, and the protocol they follow, and where as lower layers manage more data-intensive computations, controlling local devices, etc. However, the programs often get written in traditional languages that offer no mechanisms to capture these abstractions, and hence over time leads to code where the individual layers are no longer discernible. High-level protocols, though often first designed on paper using clean graphical state-machine abstractions, eventually get lost in code, and hence verification tools for such programs face the daunting task of extracting these models from the programs. The natural solution to the above problem is to build a programming language for asynchronous event-driven programs that preserves the protocol abstractions in code. Apart from the difficulty in designing such a language, this task is plagued by the reluctance of programmers to adopt a new language of programming and the discipline that it brings. However, this precise solution was pioneered by the P programming framework, where, during the development of Windows 8, the team building the USB driver stack used P for modeling, implementing, and model-checking of the USB 3.0 device drivers ( paper ) Related Blog: Building robust USB 3.0 support P: A programming language designed for asynchrony, fault-tolerance and uncertainty","title":"Case Studies"},{"location":"casestudies/#aws-amazon-s3-strong-consistency","text":"In Dec 2020, Amazon S3 launched Strong Consistency with guaranteed strong read-after-write consistency . The S3 team used automated reasoning for ensuring the correctness of S3's Strong Consistency design. Werner had a detailed blog post about the challenges involved. Qoute from Werners blog: Diving Deep on S3 Consistency Common testing techniques like unit testing and integration testing are valuable, necessary tools in any production system. But they aren\u2019t enough when you need to build a system with such a high bar for correctness. We want a system that\u2019s \u201cprovably correct\u201d, not just \u201cprobably correct.\u201d So, for strong consistency, we utilized a variety of techniques for ensuring that what we built is correct, and continues to be correct as the system evolves. We employed integration tests, deductive proofs of our proposed cache coherence algorithm, model checking to formalize our consistency design and to demonstrate its correctness, and we expanded on our model checking to examine actual runnable code. P was used for creating formal models of all the core distributed protocols involved in S3's strong consistency and model checking that the system satisfies the desired correctness guarantees. Details about P and how it is being used by the S3 team can be found in the AWS Pi-Week Talk on Use of Automated Reasoning for S3 Strong Consistency Launch .","title":"[AWS] Amazon S3 Strong Consistency"},{"location":"casestudies/#aws-amazon-iot-devices-ota-protocol","text":"AWS FreeRTOS is a real-time operating system designed to run on IoT devices to enable them to interact easily and reliably with AWS services. The Over the Air (OTA) update functionality makes it possible to update a device with security fixes quickly and reliably. The OTA Library , a part of the overall OTA functionality that runs on the IoT devices, enables customers to learn of available updates, download the updates, check their cryptographic signatures, and apply them. The OTA system is a complex piece of software that performs firmware updates reliably and securely --- keeping all devices in a consistent state --- in the presence of arbitrary failures of devices and communication. The heart of the OTA system is an intricate distributed protocol, the OTA protocol, that co-ordinates the execution of the different agents involved. P was used for creating formal models of the OTA protocol and model checking its correctness. During this process the team found 3 bugs in the model that pointed to potential issues in the actual implementation itself. Related Blog: Using Formal Methods to validate OTA Protocol","title":"[AWS] Amazon IoT Devices: OTA Protocol"},{"location":"casestudies/#uc-berkeley-programming-safe-robotics-systems","text":"DRONA is a software framework for programming safe distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the correctness of robotics software stack. The C code generated from P compiler can be deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/ See the fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram.","title":"[UC Berkeley] Programming Safe Robotics Systems"},{"location":"casestudies/#uc-berkeley-programming-secure-distributed-systems","text":"Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. PSec framework extended the P language to enable programming secure distributed systems. PSec leverages Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, PSec prevents programmers from inadvertently leaking sensitive information while sending data securely across machines. PSec was used to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here .","title":"[UC Berkeley] Programming Secure Distributed Systems"},{"location":"casestudies/#microsoft-windows-usb-30-device-drivers","text":"Event-driven asynchronous programs typically have layers of design, where the higher layers reason with how the various components (or machines) interact, and the protocol they follow, and where as lower layers manage more data-intensive computations, controlling local devices, etc. However, the programs often get written in traditional languages that offer no mechanisms to capture these abstractions, and hence over time leads to code where the individual layers are no longer discernible. High-level protocols, though often first designed on paper using clean graphical state-machine abstractions, eventually get lost in code, and hence verification tools for such programs face the daunting task of extracting these models from the programs. The natural solution to the above problem is to build a programming language for asynchronous event-driven programs that preserves the protocol abstractions in code. Apart from the difficulty in designing such a language, this task is plagued by the reluctance of programmers to adopt a new language of programming and the discipline that it brings. However, this precise solution was pioneered by the P programming framework, where, during the development of Windows 8, the team building the USB driver stack used P for modeling, implementing, and model-checking of the USB 3.0 device drivers ( paper ) Related Blog: Building robust USB 3.0 support P: A programming language designed for asynchrony, fault-tolerance and uncertainty","title":"[Microsoft] Windows USB 3.0 Device Drivers"},{"location":"manualoutline/","text":"We recommend that you start with the Tutorials to get familiar with the P language and its tool chain. P Top Level Declarations Grammar topDecl: # Top-level P Program Declarations | TypeDefDecl # UserDefinedTypeDeclaration | enumTypeDecl # EnumTypeDeclaration | eventDecl # EventDeclaration | interfaceDecl # InterfaceDeclaration | MachineDecl # MachineDeclaration | specDecl # SpecDeclaration | funDecl # GlobalFunctionDeclaration | ModuleDecl # ModuleDeclaration | testDecl # TestCaseDeclaration ; A P program consists of a collection of following high-level declarations: Top Level Declarations Description User Defined Types P supports users defined types as well as foreign types (types that are defined in external language) Enums P supports declaring enum values that can be used as int constants (update the link) Events Events are used by state machines to communicate with each other Interfaces Each machine in P implements an interface specifying the events the machine is willing to receive State Machines P state machines are used to model or implement the behavior of the system Specification Monitors P specification monitors are used to write the safety and liveness specifications the system must satisfy for correctness Global Functions P supports declaring global functions that can be shared across state machines and spec monitors Module System P supports a module system for implementing and testing the system modularly by dividing them into separate components Test Cases P test cases helps programmers to write different finite scenarios under which they would like to check the correctness of their system Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.","title":"P Program (Outline)"},{"location":"publications/","text":"P Language and Backend Analysis Compositional Programming and Testing of Dynamic Distributed Systems . Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018. Lasso detection using Partial State Caching . Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. Formal Methods in Computer-Aided Design (FMCAD) - 2017 Systematic Testing of Asynchronous Reactive Systems . Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2015). Natural proofs for Asynchronous Programs using Almost-synchronous Invariants . Ankush Desai, Pranav Garg, and P. Madhusudan. International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) - 2014 P: Safe asynchronous event-driven programming . Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien Zufferey. Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2013. Depth bounded explicit-state model checking . Abhishek Udupa, Ankush Desai and Sriram Rajamani. International SPIN Symposium on Model Checking of Software (SPIN) - 2011 P Case Studies PSec: Programming Secure Distributed Systems using Enclaves . Shivendra Kushwah, Ankush Desai, Pramod Subramanyan, Sanjit A. Seshia. Proceedings of the 2021 ACM Asia Conference on Computer and Communications Security (AsiaCCS) - 2021 Programming Safe Robotics Systems: Challenges and Advances . Ankush Desai, Shaz Qadeer and Sanjit Seshia. International Symposium On Leveraging Applications of Formal Methods, Verification and Validation (ISoLA) - 2018 DRONA: A Framework for Safe Distributed Mobile Robotics . Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS), 2017. Combining Model Checking and Runtime Verification for Safe Robotics . Ankush Desai, Tommaso Dreossi and Sanjit Seshia. The 17th International Conference on Runtime Verification (RV) - 2017 Approximate Synchrony: An Abstraction for Distributed Almost-synchronous Systems . Ankush Desai, Sanjit Seshia, Shaz Qadeer, David Broman, and John Eidson. International Conference on Computer Aided Verification (CAV) - 2015 Endlessly Circulating Messages in IEEE 1588-2008 Systems . David Broman, P Derler, Ankush Desai, John Eidson, and Sanjit Seshia. International Symposium on Precision Clock Synchronization for Measurement, Control and Communication (ISPCS) - 2014 PhD Thesis Modular and Safe Event-Driven Programming . Ankush Desai University of California, Berkeley - 2019.","title":"Publications"},{"location":"publications/#p-language-and-backend-analysis","text":"Compositional Programming and Testing of Dynamic Distributed Systems . Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018. Lasso detection using Partial State Caching . Rashmi Mudduluru, Pantazis Deligiannis, Ankush Desai, Akash Lal and Shaz Qadeer. Formal Methods in Computer-Aided Design (FMCAD) - 2017 Systematic Testing of Asynchronous Reactive Systems . Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2015). Natural proofs for Asynchronous Programs using Almost-synchronous Invariants . Ankush Desai, Pranav Garg, and P. Madhusudan. International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) - 2014 P: Safe asynchronous event-driven programming . Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien Zufferey. Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2013. Depth bounded explicit-state model checking . Abhishek Udupa, Ankush Desai and Sriram Rajamani. International SPIN Symposium on Model Checking of Software (SPIN) - 2011","title":"P Language and Backend Analysis"},{"location":"publications/#p-case-studies","text":"PSec: Programming Secure Distributed Systems using Enclaves . Shivendra Kushwah, Ankush Desai, Pramod Subramanyan, Sanjit A. Seshia. Proceedings of the 2021 ACM Asia Conference on Computer and Communications Security (AsiaCCS) - 2021 Programming Safe Robotics Systems: Challenges and Advances . Ankush Desai, Shaz Qadeer and Sanjit Seshia. International Symposium On Leveraging Applications of Formal Methods, Verification and Validation (ISoLA) - 2018 DRONA: A Framework for Safe Distributed Mobile Robotics . Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia. Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS), 2017. Combining Model Checking and Runtime Verification for Safe Robotics . Ankush Desai, Tommaso Dreossi and Sanjit Seshia. The 17th International Conference on Runtime Verification (RV) - 2017 Approximate Synchrony: An Abstraction for Distributed Almost-synchronous Systems . Ankush Desai, Sanjit Seshia, Shaz Qadeer, David Broman, and John Eidson. International Conference on Computer Aided Verification (CAV) - 2015 Endlessly Circulating Messages in IEEE 1588-2008 Systems . David Broman, P Derler, Ankush Desai, John Eidson, and Sanjit Seshia. International Symposium on Precision Clock Synchronization for Measurement, Control and Communication (ISPCS) - 2014","title":"P Case Studies"},{"location":"publications/#phd-thesis","text":"Modular and Safe Event-Driven Programming . Ankush Desai University of California, Berkeley - 2019.","title":"PhD Thesis"},{"location":"tutsoutline/","text":"We provide a collection of examples in this tutorials to get familiar with various . Client Server: A simple client-server example where a client state machine sends requests to a server state machine that performs some local computation and sends a response back to the client. We will use this example to understand P syntax, semantics, how to write specifications, run the model checker to find a bug, and then fix the bug. Two Phase Commit: Two phase commit protocol where a coordinator state machine communicates with participant state machines to ensure atomicity guarantees for transactions. We will use this example to dive deeper into how to model non-determinism in systems, how to write more complex properties in P, run the model checker, find and fix the existing bug. Failure Detector: We will use this protocol as an exercise to understand how to model node failures in P.","title":"Outline"},{"location":"videos/","text":"Introductory tutorial on P Youtube channel for P Tutorials: Youtube Channel Tech Talks and Presentations AWS Pi-Week Talk on \"Amazon S3 Strong Consisteny\" Compositional Programming and Testing of Distributed Systems (OOPSLA, 2018) Programming Safe Robotics Systems (BAIR Talk)","title":"Videos"},{"location":"videos/#introductory-tutorial-on-p","text":"Youtube channel for P Tutorials: Youtube Channel","title":"Introductory tutorial on P"},{"location":"videos/#tech-talks-and-presentations","text":"AWS Pi-Week Talk on \"Amazon S3 Strong Consisteny\" Compositional Programming and Testing of Distributed Systems (OOPSLA, 2018) Programming Safe Robotics Systems (BAIR Talk)","title":"Tech Talks and Presentations"},{"location":"whatisP/","text":".md-typeset h1, .md-content__button { display: none; } Distributed systems are notoriously hard to get right ( guaranteeing correctness ) as the programmer needs to reason about numerous control paths resulting from the myriad interleaving of events ( messages or failures ). Unsurprisingly, programmers can easily introduce subtle errors when designing these systems. Moreover, it is extremely difficult to test distributed systems, most control paths remain untested, and serious bugs lie dormant for months or even years after deployment. The P programming framework takes several steps towards addressing these challenges by providing a unified framework for modeling, specifying, implementing, testing, and verifying complex distributed systems. P Framework The P framework can be divided into three important parts: P Language P provides a high-level state machine based programming language to formally model and specify distributed systems. The syntactic sugar of state machines allows programmers to capture their system design (or protocol logic ) as communicating state machines, which is how generally programmers tend to think about their system design. P is more of a programming language than a mathematical modelling language, making it easier for the programmers to both: (1) create formal models that are closer to the implementation (sufficiently detailed) and also (2) maintain these models as the system design evolves. P supports specifying and checking both safety as well as liveness specifications (global invariants). The P module system enables programmers to model their system modularly and perform compositional testing to scale the analysis to large distributed systems. Programmers can easily write different scenarios under which they would like to check that the system satisfies the desired correctness specification. Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications. The underlying model of computation for P programs is communicating state machines (or actors ). The detailed formal semantics for P can be found here . Backend Analysis Engines P provides a backend analysis engine to systematically explores behaviors of the system model ( resulting from interleaving of messages and failures ) and check that it satisfies the desired correctness specifications. To reason about complex distributed system, the P checker needs to tackle the well-known problem of state space explosion . The P checker employs search prioritization heuristics to drive the exploration along different parts of the state space that are most likely to have concurrency related issues. The P checker is really efficient at uncovering deep bugs (i.e., require complex interleaving of events) in the system design that have a really low probability of occurance in real-world. On finding a bug, the checker provides a reproducible error-trace which the programmer can use for debugging. Though, the current P checker is great at finding deep-hard-to-find bugs (\" Heisenbugs \") in the system, it cannot provide a proof of correctness. We are actively working on addressing this challenge and are building two new backends for P. First, a symbolic execution engine that can scale the P checker to models of large distributed systems and provide sound guarantees of exploring all possible behaviors. Second, a deductive verification engine to perform mathematical proof of correctness for P programs. Both these backends will be released publicly by end of this year (2021) 1 . Code Generation P compiler currently generates C# and C code. The generated code when combined with the P Runtime (that executes the P state machines) can be deployed on any target platform. The generated C code has been used to program device drivers and robotics systems . The generated C# code has been used to program distributed systems . We are currently working on adding support for a Java backend for P. We will also be adding support for generating runtime monitors for specifications that can be then used to check if the implementation conforms to the high-level P specifications. Both these backends will be released publicly by end of this year (2021). They are currently maintained in the dev branch symbolic-codegen . \u21a9","title":"What is P?"},{"location":"whatisP/#p-framework","text":"The P framework can be divided into three important parts:","title":"P Framework"},{"location":"whatisP/#p-language","text":"P provides a high-level state machine based programming language to formally model and specify distributed systems. The syntactic sugar of state machines allows programmers to capture their system design (or protocol logic ) as communicating state machines, which is how generally programmers tend to think about their system design. P is more of a programming language than a mathematical modelling language, making it easier for the programmers to both: (1) create formal models that are closer to the implementation (sufficiently detailed) and also (2) maintain these models as the system design evolves. P supports specifying and checking both safety as well as liveness specifications (global invariants). The P module system enables programmers to model their system modularly and perform compositional testing to scale the analysis to large distributed systems. Programmers can easily write different scenarios under which they would like to check that the system satisfies the desired correctness specification. Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications. The underlying model of computation for P programs is communicating state machines (or actors ). The detailed formal semantics for P can be found here .","title":"P Language"},{"location":"whatisP/#backend-analysis-engines","text":"P provides a backend analysis engine to systematically explores behaviors of the system model ( resulting from interleaving of messages and failures ) and check that it satisfies the desired correctness specifications. To reason about complex distributed system, the P checker needs to tackle the well-known problem of state space explosion . The P checker employs search prioritization heuristics to drive the exploration along different parts of the state space that are most likely to have concurrency related issues. The P checker is really efficient at uncovering deep bugs (i.e., require complex interleaving of events) in the system design that have a really low probability of occurance in real-world. On finding a bug, the checker provides a reproducible error-trace which the programmer can use for debugging. Though, the current P checker is great at finding deep-hard-to-find bugs (\" Heisenbugs \") in the system, it cannot provide a proof of correctness. We are actively working on addressing this challenge and are building two new backends for P. First, a symbolic execution engine that can scale the P checker to models of large distributed systems and provide sound guarantees of exploring all possible behaviors. Second, a deductive verification engine to perform mathematical proof of correctness for P programs. Both these backends will be released publicly by end of this year (2021) 1 .","title":"Backend Analysis Engines"},{"location":"whatisP/#code-generation","text":"P compiler currently generates C# and C code. The generated code when combined with the P Runtime (that executes the P state machines) can be deployed on any target platform. The generated C code has been used to program device drivers and robotics systems . The generated C# code has been used to program distributed systems . We are currently working on adding support for a Java backend for P. We will also be adding support for generating runtime monitors for specifications that can be then used to check if the implementation conforms to the high-level P specifications. Both these backends will be released publicly by end of this year (2021). They are currently maintained in the dev branch symbolic-codegen . \u21a9","title":"Code Generation"},{"location":"advanced/PProject/","text":"The P compiler does not support fancy project management features like separate compilation and dependency analysis (coming soon). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in XML format. The P project file below is taken from the ClientServer from Tutorials. <Project> <IncludeProject> ../CommonUtils/Common.pproj </IncludeProject> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <Target> CSharp </Target> <ProjectName> ClientServer </ProjectName> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> can either specify the path to the P file or to a folder and the P compiler includes all the files in the folder during compilation. The <Target> block specifies the target language for code generation (options are: CSharp, C, RVM and we are adding support for Java). The <ProjectName> block provides the name for the project which is used as the output file name. The <OutputDir> block provides the output directory for the generated code. Finally, <IncludeProject> block provides path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Coming Soon Example about how to use <IncludeProject> feature will be added soon.","title":"P Project File"},{"location":"advanced/structureOfPProgram/","text":"A P program is typically divided into following four folders (or parts): PSrc : contains all the state machines representing the implementation (model) of the system or protocol to be verified or tested. PSpec : contains all the specifications representing the correctness properties that the system must satisfy. PTst : contains all the environment or test harness state machines that model the non-deterministic scenarios under which we want to check that the system model in PSrc satisfies the specifications in PSpec . P allows writing different model checking scenarios as test-cases. PForeign : P also supports interfacing with foreign languages like Java , C# , and C/C++ . P allows programmers to implement a part of their protocol logic in these foreign languages and use them in a P program using the Foreign types and functions interface ( Foreign ) The PForeign folder contains all the foreign code used in the P program. Recommendation The folder structure described above is just a recommendation. The P compiler does not require any particular folder structure for a P project. The examples in the Tutorials use the same folder structure. Models, Specifications, Model Checking Scenario A quick primer on what a model is, versus a specification, and model checking scenarios: (1) A specification says what the system should do (correctness properties). (2) A model captures the details of how the system does it. (3) A model checking scenario provides the finite non-deterministc test-harness or environment under which the model checker should check that the system model satisfies its specifications.","title":"Structure of a P Program"},{"location":"getstarted/build/","text":"If you plan to contribute a Pull Request to P then you need to be able to build the source code and run the tests. Please make sure that you have followed the steps in the [installation guide] to install P dependencies. Building the P project Clone the P repo and run the following build script. on MacOS or Linux cd Bld ./build.sh On Windows cd Bld ./build.ps1 Running the tests You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the P.sln . dotnet build --configuration Release dotnet test --configuration Release","title":"Building from Source"},{"location":"getstarted/build/#building-the-p-project","text":"Clone the P repo and run the following build script. on MacOS or Linux cd Bld ./build.sh On Windows cd Bld ./build.ps1","title":"Building the P project"},{"location":"getstarted/build/#running-the-tests","text":"You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the P.sln . dotnet build --configuration Release dotnet test --configuration Release","title":"Running the tests"},{"location":"getstarted/install/","text":"P is cross platform and can be used on MacOS, Linux, and Windows. We provide a step-by-step guide for installing P along with its required dependencies. After each step, please use the troubleshooting check to ensure that each installation step succeeded. [Step 1] Install .Net Core SDK The P compiler and checker are implemented in C# and hence the tool chain requires dotnet . P currently uses the specific version of .Net SDK 3.1 . To install .Net Core 3.1 SDK use: MacOS Installing .Net SDK on MacOS using Homebrew ( details ) brew tap isen-ng/dotnet-sdk-versions brew install --cask dotnet-sdk3-1-400 Dont have Homebrew? Install directly using the installer . Ubuntu Installing .Net SDK on Ubuntu ( details ) wget https://packages.microsoft.com/config/ubuntu/21.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb sudo apt-get update; \\ sudo apt-get install -y apt-transport-https && \\ sudo apt-get update && \\ sudo apt-get install -y dotnet-sdk-3.1 Amazon Linux Installing .Net SDK on Amazon Linux ( details ) sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install dotnet-sdk-3.1 Windows Installing .Net SDK on Windows using the installer ( details ) Troubleshoot: Confirm that dotnet is correctly installed on your machine. dotnet --list-sdks You must see an SDK with 3.1.* dotnet version installed. If you get dotnet command not found error, mostly likely, you need to add the path to dotnet in your PATH . [Step 2] Install Java Runtime P compiler uses ANTLR parser and hence requires java . If you already have Java installed please ignore this step. To install Java use: MacOS Installing Java on MacOS using Homebrew ( details ) brew install java Dont have Homebrew? Directly use installer . Ubuntu Installing Java on Ubuntu ( details ) sudo apt install default-jre Amazon Linux Installing Java 8 on Amazon Linux (you can use any version of java > 8) sudo yum install java-1.8.0-openjdk Windows Installing Java on Windows ( details ) Troubleshoot: Confirm that java is correctly installed on your machine. java -version If you get java command not found error, mostly likely, you need to add the path to java in your PATH . [Step 3] Install P Compiler Install the P compiler as a dotnet tool using the following command: dotnet tool install --global P Troubleshoot: Confirm that pc is correctly installed on your machine After installation, run which pc and it should show: which pc /Users/<user>/.dotnet/tools/pc If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting an error that pc command not found, its most likely that $HOME/.dotnet/tools is not in your PATH . Updating P Compiler You can update the version of P compiler by running the following command: dotnet tool update --global P [Step 4] Install P Checker The current P checker depends on Coyote (previously P# ) Install the Coyote version 1.0.5 using the following command: dotnet tool install --global Microsoft.Coyote.CLI --version 1.0.5 Troubleshoot: Confirm that coyote is correctly installed on your machine After installation, run which coyote and it should show: which coyote coyote is /Users/<user>/.dotnet/tools/coyote If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting an error that coyote command not found, its most likely that $HOME/.dotnet/tools is not in your PATH . We highly recommend that you create the following alias as we use it in the rest of tutorials and getting started guide: On MacOS or Linux Add following alias to the bash profile ( ~/.bash_profile or the equivalent on your system) so that you can invoke the P checker ( pmc ) directly. alias pmc = 'coyote test' On Windows We recommend that you add the following to the Microsoft.PowerShell_profile normally found in D:\\Users\\<username>\\Documents\\WindowsPowerShell function pmc { coyote test $args } [Step 5] Recommended IDE (Optional) For developing P programs, we recommend using IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows. For debugging generated Java code, we recommend using IntelliJ IDEA Using P Great ! You are all set to compile and test your first P program !","title":"Installing P"},{"location":"getstarted/install/#step-1-install-net-core-sdk","text":"The P compiler and checker are implemented in C# and hence the tool chain requires dotnet . P currently uses the specific version of .Net SDK 3.1 . To install .Net Core 3.1 SDK use: MacOS Installing .Net SDK on MacOS using Homebrew ( details ) brew tap isen-ng/dotnet-sdk-versions brew install --cask dotnet-sdk3-1-400 Dont have Homebrew? Install directly using the installer . Ubuntu Installing .Net SDK on Ubuntu ( details ) wget https://packages.microsoft.com/config/ubuntu/21.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb sudo apt-get update; \\ sudo apt-get install -y apt-transport-https && \\ sudo apt-get update && \\ sudo apt-get install -y dotnet-sdk-3.1 Amazon Linux Installing .Net SDK on Amazon Linux ( details ) sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install dotnet-sdk-3.1 Windows Installing .Net SDK on Windows using the installer ( details ) Troubleshoot: Confirm that dotnet is correctly installed on your machine. dotnet --list-sdks You must see an SDK with 3.1.* dotnet version installed. If you get dotnet command not found error, mostly likely, you need to add the path to dotnet in your PATH .","title":"[Step 1] Install .Net Core SDK"},{"location":"getstarted/install/#step-2-install-java-runtime","text":"P compiler uses ANTLR parser and hence requires java . If you already have Java installed please ignore this step. To install Java use: MacOS Installing Java on MacOS using Homebrew ( details ) brew install java Dont have Homebrew? Directly use installer . Ubuntu Installing Java on Ubuntu ( details ) sudo apt install default-jre Amazon Linux Installing Java 8 on Amazon Linux (you can use any version of java > 8) sudo yum install java-1.8.0-openjdk Windows Installing Java on Windows ( details ) Troubleshoot: Confirm that java is correctly installed on your machine. java -version If you get java command not found error, mostly likely, you need to add the path to java in your PATH .","title":"[Step 2] Install Java Runtime"},{"location":"getstarted/install/#step-3-install-p-compiler","text":"Install the P compiler as a dotnet tool using the following command: dotnet tool install --global P Troubleshoot: Confirm that pc is correctly installed on your machine After installation, run which pc and it should show: which pc /Users/<user>/.dotnet/tools/pc If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting an error that pc command not found, its most likely that $HOME/.dotnet/tools is not in your PATH . Updating P Compiler You can update the version of P compiler by running the following command: dotnet tool update --global P","title":"[Step 3] Install P Compiler"},{"location":"getstarted/install/#step-4-install-p-checker","text":"The current P checker depends on Coyote (previously P# ) Install the Coyote version 1.0.5 using the following command: dotnet tool install --global Microsoft.Coyote.CLI --version 1.0.5 Troubleshoot: Confirm that coyote is correctly installed on your machine After installation, run which coyote and it should show: which coyote coyote is /Users/<user>/.dotnet/tools/coyote If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. If you are getting an error that coyote command not found, its most likely that $HOME/.dotnet/tools is not in your PATH . We highly recommend that you create the following alias as we use it in the rest of tutorials and getting started guide: On MacOS or Linux Add following alias to the bash profile ( ~/.bash_profile or the equivalent on your system) so that you can invoke the P checker ( pmc ) directly. alias pmc = 'coyote test' On Windows We recommend that you add the following to the Microsoft.PowerShell_profile normally found in D:\\Users\\<username>\\Documents\\WindowsPowerShell function pmc { coyote test $args }","title":"[Step 4] Install P Checker"},{"location":"getstarted/install/#step-5-recommended-ide-optional","text":"For developing P programs, we recommend using IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. For debugging generated C# code, we recommend using Rider for Mac/Linux or Visual Studio 2019 for Windows. For debugging generated Java code, we recommend using IntelliJ IDEA","title":"[Step 5] Recommended IDE (Optional)"},{"location":"getstarted/install/#using-p","text":"Great ! You are all set to compile and test your first P program !","title":"Using P"},{"location":"getstarted/syntaxhighlight/","text":"Syntax Highlighting for P in IntelliJ To enable basic syntax highlighting for P ( *.p files) in IntelliJ, download the zip file here and import it as settings into IntelliJ. Tip Details about how to import settings into IntelliJ from a zip archive ( check here ) Syntax Highlighting for P in Sublime We used to support syntax highlighting for Sublime editor but is no longer maintained and hence may not support latest P language features. ( Sublime Plugin for P (.p) files ). Troubleshooting If you face any issues getting the syntax highlighting to work, please create an issue on the P Github repository.","title":"Syntax Highlighting for P"},{"location":"getstarted/syntaxhighlight/#syntax-highlighting-for-p-in-intellij","text":"To enable basic syntax highlighting for P ( *.p files) in IntelliJ, download the zip file here and import it as settings into IntelliJ. Tip Details about how to import settings into IntelliJ from a zip archive ( check here )","title":"Syntax Highlighting for P in IntelliJ"},{"location":"getstarted/syntaxhighlight/#syntax-highlighting-for-p-in-sublime","text":"We used to support syntax highlighting for Sublime editor but is no longer maintained and hence may not support latest P language features. ( Sublime Plugin for P (.p) files ).","title":"Syntax Highlighting for P in Sublime"},{"location":"getstarted/syntaxhighlight/#troubleshooting","text":"If you face any issues getting the syntax highlighting to work, please create an issue on the P Github repository.","title":"Troubleshooting"},{"location":"getstarted/usingP/","text":"Before moving forward, we assume that you have successfully installed the P Compiler and Checker and the syntax highlighting plugin . We introduce the P language syntax and semantics in details in the Tutorials and Language Manual . In this section, we provide an overview of the steps involved in compiling and testing a P program using the client server example. Get the Client Server Example Locally We will use the ClientServer example from Tutorial folder in P repository to describe the process of compiling and testing a P program. Please clone the P repo and navigate to the ClientServer example in Tutorial. Clone P Repo locally: git clone https://github.com/p-org/P.git Navigate to the ClientServer examples folder: cd <P cloned folder>/Tutorial/ClientServer Compiling a P program There are two ways of compiling a P program: (1) using a P project file ( *.pproj ) to provides all the required inputs to the compiler or (2) passing the P files ( *.p ) along with other options (e.g., -generate ) as commandline arguments to the compiler. We recommend always using the P project files to compile a P program. P Compiler commandline options: The P compiler provides the following commandline options: ------------------------------------------ Recommended usage: >> pc -proj:<.pproj file> ------------------------------------------ Optional usage: >> pc file1.p [ file2.p ... ][ options ] ------------------------------------------ options: -t: [ target project name ] -- project name ( as well as the generated file ) if not supplied, use file1 -outputDir: [ path ] -- where to write the generated files -aspectOutputDir: [ path ] -- where to write the generated aspectj files if not supplied, use outputDir -generate: [ C,CSharp,RVM ] -- select a target language to generate C : generate C code CSharp : generate C# code RVM : generate Monitor code -h, -help, --help -- display this help message ------------------------------------------ Compile using the P Project Compiling the ClientServer project using the P Project file: pc -proj:ClientServer.pproj Expected Output $ pc -proj:ClientServer.pproj ---------------------------------------- ==== Loading project file: ClientServer.pproj ....... includes p file: P/Tutorial/ClientServer/PSrc/ClientServer.p ....... includes p file: P/Tutorial/ClientServer/PSrc/AbstractServer.p ....... includes p file: P/Tutorial/ClientServer/PSpec/Monotonic.p ....... includes p file: /P/Tutorial/ClientServer/PTst/Modules.p ....... includes p file: P/Tutorial/ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.8.3+39993bd9d for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... Restored P/Tutorial/ClientServer/ClientServer.csproj. ClientServer -> P/Tutorial/ClientServer/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) ---------------------------------------- P Project File Details The P compiler does not support project management features like separate compilation and dependency analysis (coming soon). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in a XML format. <Project> <IncludeProject> ../CommonUtils/Common.pproj </IncludeProject> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <Target> CSharp </Target> <ProjectName> ClientServer </ProjectName> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> can either specify the path to a P file or to a folder and the P compiler includes all the *.p files in the folder during compilation. The <Target> block specifies the target language for code generation (options are: CSharp, C, RVM and we are adding support for Java). The <ProjectName> block provides the name for the project which is used as the output file name for the generated code. The <OutputDir> block provides the output directory for the generated code. Finally, <IncludeProject> block provides path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Compile P files directly Compiling the ClientServer program by passing all the required inputs as commandline arguments: pc PSpec/*.p PSrc/*.p PTst/*.p \\ -generate:csharp -outputDir:PGenerated -target:ClientServer Expected Output ....... includes p file: P/Tutorial/ClientServer/PSpec/Monotonic.p ....... includes p file: P/Tutorial/ClientServer/PSrc/AbstractServer.p ....... includes p file: P/Tutorial/ClientServer/PSrc/ClientServer.p ....... includes p file: P/Tutorial/ClientServer/PTst/Modules.p ....... includes p file: P/Tutorial/ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.10.2+857e5a733 for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... All projects are up-to-date for restore. ClientServer -> /Users/ankushpd/Workspace/github/P/Tutorial/ClientServer/PGenerated/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) Testing a P program Compiling the ClientServer program generates a ClientServer.dll , this dll is the C# representation of the P program. The P Checker takes as input this dll and systematically explores behaviors of the program for the specific test case. The path to the dll is present in the generated compilation output, check for line: ClientServer -> <Path>/ClientServer.dll You can get the list of test cases defined in the P program by passing the generated dll to the P Checker: pmc <Path>/ClientServer.dll Expected Output: pmc <Path>/ClientServer.dll Provide /method flag to qualify the test method name you wish to use. Possible options are:: PImplementation.singleClientServer.Execute PImplementation.multipleClientsServer.Execute PImplementation.singleClientServerWithLiveness.Execute There are three test cases defined in the ClientServer P project and you can specify which test case to run by using the -m or /method parameter along with the -i parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system. So you test the singleClientServer test case for 100 schedules, we can use the following command: pmc <Path>/ClientServer.dll \\ -m PImplementation.singleClientServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.singleClientServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.singleClientServer.Execute Starting TestingProcessScheduler in process 61218 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:3216586065). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 30 (min), 30 (avg), 30 (max). ... Elapsed 0.407219 sec. . Done There is a known bug in the ClientServer example (explain in the Tutorials) which is caught by the multipleClientsServer test case. Run command: pmc <Path>/ClientServer.dll \\ -m PImplementation.multipleClientsServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.multipleClientsServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.multipleClientsServer.Execute Starting TestingProcessScheduler in process 62234 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:719852850). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing <Path>/ClientServer_0_0.txt ..... Writing <Path>/ClientServer_0_0.schedule ... Elapsed 0.2006624 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 17 (min), 17 (avg), 17 (max). ... Elapsed 0.3386085 sec. . Done The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a text file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the intial state to the error state. (2) a schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program for the generated error trace for debugging (more details about debugging P error traces: here ).","title":"Using P Compiler and Checker"},{"location":"getstarted/usingP/#compiling-a-p-program","text":"There are two ways of compiling a P program: (1) using a P project file ( *.pproj ) to provides all the required inputs to the compiler or (2) passing the P files ( *.p ) along with other options (e.g., -generate ) as commandline arguments to the compiler. We recommend always using the P project files to compile a P program. P Compiler commandline options: The P compiler provides the following commandline options: ------------------------------------------ Recommended usage: >> pc -proj:<.pproj file> ------------------------------------------ Optional usage: >> pc file1.p [ file2.p ... ][ options ] ------------------------------------------ options: -t: [ target project name ] -- project name ( as well as the generated file ) if not supplied, use file1 -outputDir: [ path ] -- where to write the generated files -aspectOutputDir: [ path ] -- where to write the generated aspectj files if not supplied, use outputDir -generate: [ C,CSharp,RVM ] -- select a target language to generate C : generate C code CSharp : generate C# code RVM : generate Monitor code -h, -help, --help -- display this help message ------------------------------------------ Compile using the P Project Compiling the ClientServer project using the P Project file: pc -proj:ClientServer.pproj Expected Output $ pc -proj:ClientServer.pproj ---------------------------------------- ==== Loading project file: ClientServer.pproj ....... includes p file: P/Tutorial/ClientServer/PSrc/ClientServer.p ....... includes p file: P/Tutorial/ClientServer/PSrc/AbstractServer.p ....... includes p file: P/Tutorial/ClientServer/PSpec/Monotonic.p ....... includes p file: /P/Tutorial/ClientServer/PTst/Modules.p ....... includes p file: P/Tutorial/ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.8.3+39993bd9d for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... Restored P/Tutorial/ClientServer/ClientServer.csproj. ClientServer -> P/Tutorial/ClientServer/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s) ---------------------------------------- P Project File Details The P compiler does not support project management features like separate compilation and dependency analysis (coming soon). The current project file interface is a simple mechanism to provide all the required inputs to the compiler in a XML format. <Project> <IncludeProject> ../CommonUtils/Common.pproj </IncludeProject> <InputFiles> <PFile> ./PSrc/ </PFile> <PFile> ./PSpec/ </PFile> <PFile> ./PTst/ </PFile> </InputFiles> <Target> CSharp </Target> <ProjectName> ClientServer </ProjectName> <OutputDir> ./PGenerated/ </OutputDir> </Project> The <InputFiles> block provides all the P files that must be compiled together for this project. In <PFile> can either specify the path to a P file or to a folder and the P compiler includes all the *.p files in the folder during compilation. The <Target> block specifies the target language for code generation (options are: CSharp, C, RVM and we are adding support for Java). The <ProjectName> block provides the name for the project which is used as the output file name for the generated code. The <OutputDir> block provides the output directory for the generated code. Finally, <IncludeProject> block provides path to other P projects that must be included as dependencies during compilation. The P compiler simply recursively copies all the P files in the dependency projects (transitively including all P files in dependent projects) and compiles them together. This feature provides a way to split the P models for a large system into sub projects that can share models. Compile P files directly Compiling the ClientServer program by passing all the required inputs as commandline arguments: pc PSpec/*.p PSrc/*.p PTst/*.p \\ -generate:csharp -outputDir:PGenerated -target:ClientServer Expected Output ....... includes p file: P/Tutorial/ClientServer/PSpec/Monotonic.p ....... includes p file: P/Tutorial/ClientServer/PSrc/AbstractServer.p ....... includes p file: P/Tutorial/ClientServer/PSrc/ClientServer.p ....... includes p file: P/Tutorial/ClientServer/PTst/Modules.p ....... includes p file: P/Tutorial/ClientServer/PTst/TestDriver.p ....... includes p file: P/Tutorial/ClientServer/PTst/Testscript.p ---------------------------------------- ---------------------------------------- Parsing .. Type checking ... Code generation .... Generated ClientServer.cs ---------------------------------------- Compiling ClientServer.csproj .. Microsoft (R) Build Engine version 16.10.2+857e5a733 for .NET Copyright (C) Microsoft Corporation. All rights reserved. Determining projects to restore... All projects are up-to-date for restore. ClientServer -> /Users/ankushpd/Workspace/github/P/Tutorial/ClientServer/PGenerated/netcoreapp3.1/ClientServer.dll Build succeeded. 0 Warning(s) 0 Error(s)","title":"Compiling a P program"},{"location":"getstarted/usingP/#testing-a-p-program","text":"Compiling the ClientServer program generates a ClientServer.dll , this dll is the C# representation of the P program. The P Checker takes as input this dll and systematically explores behaviors of the program for the specific test case. The path to the dll is present in the generated compilation output, check for line: ClientServer -> <Path>/ClientServer.dll You can get the list of test cases defined in the P program by passing the generated dll to the P Checker: pmc <Path>/ClientServer.dll Expected Output: pmc <Path>/ClientServer.dll Provide /method flag to qualify the test method name you wish to use. Possible options are:: PImplementation.singleClientServer.Execute PImplementation.multipleClientsServer.Execute PImplementation.singleClientServerWithLiveness.Execute There are three test cases defined in the ClientServer P project and you can specify which test case to run by using the -m or /method parameter along with the -i parameter to specify how many different schedules to explore when running this test case (by default the checker explores a single schedule). For complex systems, running for 100,000 schedules typically finds most of the easy to find bugs before running the checker on a distributed cluster to explore billions of schedules and rule out deep bugs in the system. So you test the singleClientServer test case for 100 schedules, we can use the following command: pmc <Path>/ClientServer.dll \\ -m PImplementation.singleClientServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.singleClientServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.singleClientServer.Execute Starting TestingProcessScheduler in process 61218 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:3216586065). ..... Iteration #1 ..... Iteration #2 ..... Iteration #3 ..... Iteration #4 ..... Iteration #5 ..... Iteration #6 ..... Iteration #7 ..... Iteration #8 ..... Iteration #9 ..... Iteration #10 ..... Iteration #20 ..... Iteration #30 ..... Iteration #40 ..... Iteration #50 ..... Iteration #60 ..... Iteration #70 ..... Iteration #80 ..... Iteration #90 ..... Iteration #100 ... Testing statistics: ..... Found 0 bugs. ... Scheduling statistics: ..... Explored 100 schedules: 100 fair and 0 unfair. ..... Number of scheduling points in fair terminating schedules: 30 (min), 30 (avg), 30 (max). ... Elapsed 0.407219 sec. . Done There is a known bug in the ClientServer example (explain in the Tutorials) which is caught by the multipleClientsServer test case. Run command: pmc <Path>/ClientServer.dll \\ -m PImplementation.multipleClientsServer.Execute \\ -i 100 Expected Output pmc <Path>/ClientServer.dll -m PImplementation.multipleClientsServer.Execute -i 100 . Testing <Path>/ClientServer.dll ... Method PImplementation.multipleClientsServer.Execute Starting TestingProcessScheduler in process 62234 ... Created '1' testing task. ... Task 0 is using 'random' strategy (seed:719852850). ..... Iteration #1 ... Task 0 found a bug. ... Emitting task 0 traces: ..... Writing <Path>/ClientServer_0_0.txt ..... Writing <Path>/ClientServer_0_0.schedule ... Elapsed 0.2006624 sec. ... Testing statistics: ..... Found 1 bug. ... Scheduling statistics: ..... Explored 1 schedule: 1 fair and 0 unfair. ..... Found 100.00% buggy schedules. ..... Number of scheduling points in fair terminating schedules: 17 (min), 17 (avg), 17 (max). ... Elapsed 0.3386085 sec. . Done The P checker on finding a bug generates two artifacts (highlighted in the expected output above): (1) a text file (e.g., ClientServer_0_0.txt ) that has the readable error trace representing the sequence of steps from the intial state to the error state. (2) a schedule file (e.g., ClientServer_0_0.schedule ) that can be used to replay the error trace and single step through the P program for the generated error trace for debugging (more details about debugging P error traces: here ).","title":"Testing a P program"},{"location":"howtoguides/debuggingerror/","text":"","title":"Debugging Error Traces (counter examples)"},{"location":"howtoguides/importanceliveness/","text":"","title":"Importance of Liveness Specifications"},{"location":"howtoguides/modelbasedtesting/","text":"","title":"Modelbasedtesting"},{"location":"howtoguides/sharedmemory/","text":"","title":"Modeling Shared Memory Concurrency"},{"location":"manual/datatypes/","text":"P Supports the following data types: P Types Description Primitive int , bool , float , string , enum , machine , and event . Record tuple and named tuple Collection map , seq , and set Foreign These are types that are not defined in P but in an external language (e.g., C# or Java) and can be used in the P program. User Defined These are user defined types that are constructed using any of the P types listed above Universal Supertypes any and data P Types Grammar Data types in P: type : | bool # PrimitiveType | int # PrimitiveType | float # PrimitiveType | string # PrimitiveType | event # PrimitiveType | machine # PrimitiveType | (type (, type)*) # TupleType | (iden: type (, iden: type)*) # NamedTupleType | seq[type] # SeqType | set[type] # SetType | map[type, type] # MapType | data # UniversalType | any # UniversalType | iden # UserDefinedType ; Declaring user defined types and foreign types: typeDecl : | type iden ; # ForeignTypeDeclaration | type iden = type ; # UserDefinedTypeDeclaration ; Declaring enum types: enumTypeDecl : | enum iden { enumElemList } | enum iden { numberedEnumElemList } ; enumElemList : enumElem (, enumElem)* ; enumElem : iden ; numberedEnumElemList : numberedEnumElem (, numberedEnumElem)* ; numberedEnumElem : iden = IntLiteral ; Operations on P data types Details for the operations that can be performed on P datatypes are described in the expressions and statements . Primitive P supports the common primitive datatypes like int , bool , float , and string . Two additional primitive data types that are specific to the P language are event and machine . event type represents the set of all P events. Similarly, machine type represents the set of all machine references. Primitive Data types ... event eRequest : bool ; ... // some function body in the P program { var i : int ; var j : float ; var k : string ; var l : bool ; var ev : event ; var client : machine ; ev = eRequest ; client = new Client (); i = 10 ; j = 10.0 ; k = \"Failure!!\" ; l = ( i == ( j to int )); assert l , k ; send client , ev , l ; } Enum P supports enums, enum values in P are considered as global constants and must have unique name. Enums by default are given integer values starting from 0 (if no values are assigned to the elements). Enums in P can be coerced to int . Please refer to the grammar above for the syntax for declaring enums. Enum Declaration enum tResponseStatus { ERROR, SUCCESS, TIMEOUT } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 0; Enum Declaration with Values enum tResponseStatus { ERROR = 500, SUCCESS = 200, TIMEOUT = 400; } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 500; Record P supports two types of records: tuples and named tuples. The fields of a tuple can be accessed by using the . operation followed by the field index. // tuple with three fields var tupleEx: (int, bool, int); // constructing a value of tuple type. tupleEx = (20, false, 21); // accessing the first and third element of the tupleEx tupleEx.0 = tupleEx.0 + tupleEx.2; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. // named tuple with three fields var namedTupleEx: (x1: int, x2: bool, x3: int); // constructing a value of named tuple type. namedTupleEx = (x1 = 20, x2 = false, x3 = 21); // accessing the first and third element of the namedTupleEx namedTupleEx.x1 = namedTupleEx.x1 + namedTupleEx.x3; Note Tuple and Named tuple types are disjoint, i.e., a tuple of type (int, bool, int) cannot to assigned to a variable of tuple (x1: int, x2: bool, x3: int) though the elements of the tuple have same types (and vice versa). And similarly, a named tuple of type (x1: int, x2: bool, x3: int) cannot to assigned to a variable of tuple (y1: int, y2: bool, y3: int) they are two distinct types. Collection P supports three collection types: map, sequence (lists), and set. The operations to mutate the collection types like insert, update, and remove elements are described in the statements section. One can use the while loop to iterate over these collection types. Other operations like sizeof , in (to check containment), choose (pick a value nondeterministically), keys , and values on these collection types are defined in the expressions section. Syntax : map[K, V] represents a map type with keys of type K and values of type V . seq[T] represents a sequence type with elements of type T . set[T] represents a set type with elements of type T . Foreign P allows programmers to define (or implement) types in the external languages. We refer to these types as foreign types, they are declared in P but are implemented in an external language. They can be used inside P programs just like any other types. Syntax: : type tName; tName is the name of the foreign type. Note that foreign types are disjoint from all other types in P. They are subtype of the any type. Details about how to define/implement foreign types in P is described here . User Defined P supports assigning names to type i.e., creating typedef . Note that these typedefs are simply assigning names to P types and does not effect the sub-typing relation. Syntax: : type iden = type ; User Defined Type Declaration // defining a type tLookUpRequest type tLookUpRequest = ( client : machine , requestId : int , key : string ); // defining a type tLookUpRequestX type tLookUpRequestX = ( client : machine , requestId : int , key : string ); The programmers can use type tLookUpRequest as a short hand for referring to the type (client: machine, requestId: int, key: string) Note that the types tLookUpRequest and tLookUpRequestX are same, the compiler does not distinguish between the two types. Universal Supertypes P supports two universal supertypes ( any and data ), type that are supertypes of all types in the language. any type in P is the supertype of all types. Also, note that in P, seq[any] is a super type of seq[int] and similarly for other collection types. data type in P is the supertype of all types in P that do not have a machine type embedded in it. This type is mainly used to represent values in P that do not have a machine reference embedded in them i.e., the value is purely \"data\" and has no machine \"references\" in it. For example, data is a supertype of (key: string, value: int) but not (key: string, client: machine) . Default values for P data types The default feature in P (checkout details in expressions ) can be used to obtain the default value of any P type. P variables on declaration are automatically initialized to their default values. default values of P types P variables on declaration are automatically initialized to their default values. For example: var s : set[int]; // by default a set type is initialized to an empty set assert sizeof(s) == 0; s += (100); assert sizeof(s) == 1; // reset the variable to an empty set s = default(set[int]); Similarly, type tRequest = (client: machine, requestId: int); type tResponse = (values: map[int, int]); ... // initializes x to (client = null, requestId = 0); x = default(tRequest); // initializes y to (values = {}), empty map. y = default(tResponse); assert x.client == default(machine); assert sizeof(y.values) == 0; P Types Default Value int 0 float 0.0 bool false string \"\" event null machine null enum element of the enum with lowest (int) value Record (tuple or named tuple) Each field in the record type is initialized to its default value. Collection (set, seq, and map) Empty collection Foreign null any and data null","title":"P DataTypes"},{"location":"manual/datatypes/#primitive","text":"P supports the common primitive datatypes like int , bool , float , and string . Two additional primitive data types that are specific to the P language are event and machine . event type represents the set of all P events. Similarly, machine type represents the set of all machine references. Primitive Data types ... event eRequest : bool ; ... // some function body in the P program { var i : int ; var j : float ; var k : string ; var l : bool ; var ev : event ; var client : machine ; ev = eRequest ; client = new Client (); i = 10 ; j = 10.0 ; k = \"Failure!!\" ; l = ( i == ( j to int )); assert l , k ; send client , ev , l ; }","title":"Primitive"},{"location":"manual/datatypes/#enum","text":"P supports enums, enum values in P are considered as global constants and must have unique name. Enums by default are given integer values starting from 0 (if no values are assigned to the elements). Enums in P can be coerced to int . Please refer to the grammar above for the syntax for declaring enums. Enum Declaration enum tResponseStatus { ERROR, SUCCESS, TIMEOUT } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 0; Enum Declaration with Values enum tResponseStatus { ERROR = 500, SUCCESS = 200, TIMEOUT = 400; } // usage of enums var status: tResponseStatus; status = ERROR; // you can coerce an enum to int assert (ERROR to int) == 500;","title":"Enum"},{"location":"manual/datatypes/#record","text":"P supports two types of records: tuples and named tuples. The fields of a tuple can be accessed by using the . operation followed by the field index. // tuple with three fields var tupleEx: (int, bool, int); // constructing a value of tuple type. tupleEx = (20, false, 21); // accessing the first and third element of the tupleEx tupleEx.0 = tupleEx.0 + tupleEx.2; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. // named tuple with three fields var namedTupleEx: (x1: int, x2: bool, x3: int); // constructing a value of named tuple type. namedTupleEx = (x1 = 20, x2 = false, x3 = 21); // accessing the first and third element of the namedTupleEx namedTupleEx.x1 = namedTupleEx.x1 + namedTupleEx.x3; Note Tuple and Named tuple types are disjoint, i.e., a tuple of type (int, bool, int) cannot to assigned to a variable of tuple (x1: int, x2: bool, x3: int) though the elements of the tuple have same types (and vice versa). And similarly, a named tuple of type (x1: int, x2: bool, x3: int) cannot to assigned to a variable of tuple (y1: int, y2: bool, y3: int) they are two distinct types.","title":"Record"},{"location":"manual/datatypes/#collection","text":"P supports three collection types: map, sequence (lists), and set. The operations to mutate the collection types like insert, update, and remove elements are described in the statements section. One can use the while loop to iterate over these collection types. Other operations like sizeof , in (to check containment), choose (pick a value nondeterministically), keys , and values on these collection types are defined in the expressions section. Syntax : map[K, V] represents a map type with keys of type K and values of type V . seq[T] represents a sequence type with elements of type T . set[T] represents a set type with elements of type T .","title":"Collection"},{"location":"manual/datatypes/#foreign","text":"P allows programmers to define (or implement) types in the external languages. We refer to these types as foreign types, they are declared in P but are implemented in an external language. They can be used inside P programs just like any other types. Syntax: : type tName; tName is the name of the foreign type. Note that foreign types are disjoint from all other types in P. They are subtype of the any type. Details about how to define/implement foreign types in P is described here .","title":"Foreign"},{"location":"manual/datatypes/#user-defined","text":"P supports assigning names to type i.e., creating typedef . Note that these typedefs are simply assigning names to P types and does not effect the sub-typing relation. Syntax: : type iden = type ; User Defined Type Declaration // defining a type tLookUpRequest type tLookUpRequest = ( client : machine , requestId : int , key : string ); // defining a type tLookUpRequestX type tLookUpRequestX = ( client : machine , requestId : int , key : string ); The programmers can use type tLookUpRequest as a short hand for referring to the type (client: machine, requestId: int, key: string) Note that the types tLookUpRequest and tLookUpRequestX are same, the compiler does not distinguish between the two types.","title":"User Defined"},{"location":"manual/datatypes/#universal-supertypes","text":"P supports two universal supertypes ( any and data ), type that are supertypes of all types in the language. any type in P is the supertype of all types. Also, note that in P, seq[any] is a super type of seq[int] and similarly for other collection types. data type in P is the supertype of all types in P that do not have a machine type embedded in it. This type is mainly used to represent values in P that do not have a machine reference embedded in them i.e., the value is purely \"data\" and has no machine \"references\" in it. For example, data is a supertype of (key: string, value: int) but not (key: string, client: machine) .","title":"Universal Supertypes"},{"location":"manual/datatypes/#default-values-for-p-data-types","text":"The default feature in P (checkout details in expressions ) can be used to obtain the default value of any P type. P variables on declaration are automatically initialized to their default values. default values of P types P variables on declaration are automatically initialized to their default values. For example: var s : set[int]; // by default a set type is initialized to an empty set assert sizeof(s) == 0; s += (100); assert sizeof(s) == 1; // reset the variable to an empty set s = default(set[int]); Similarly, type tRequest = (client: machine, requestId: int); type tResponse = (values: map[int, int]); ... // initializes x to (client = null, requestId = 0); x = default(tRequest); // initializes y to (values = {}), empty map. y = default(tResponse); assert x.client == default(machine); assert sizeof(y.values) == 0; P Types Default Value int 0 float 0.0 bool false string \"\" event null machine null enum element of the enum with lowest (int) value Record (tuple or named tuple) Each field in the record type is initialized to its default value. Collection (set, seq, and map) Empty collection Foreign null any and data null","title":"Default values for P data types"},{"location":"manual/events/","text":"A P program is a collection of state machines communicating with each other by exchanging events . An event in P has two parts, an event name and a payload value (optional) that can be sent along with the event. P Event Declaration Grammar eventDecl : | event iden (: type)?; # P Event Declaration iden is the name of the event and type is any P data type ( decribed here ). Syntax: event eName; or event eName : payloadType; eName is the name of the P event and payloadType is the type of payload values that can sent along with this event. Event Declarations // declarations of events with no payloads event ePing ; event ePong ; // declaration of events that have payloads type tRequest = ( client : Client , key : string , value : int , requestId : int ); // eRequest event with payload of type tRequest event eRequest : tRequest ; // eResponse event that can have a payload of type (requestId: int, status: bool) event eResponse : ( requestId : int , status : bool );","title":"P Events"},{"location":"manual/expressions/","text":"A Function in P can be arbitrary piece of imperative code which enables programmers to capture complex protocol logic in their state machines. P supports the common imperative programming language expressions (just like in Java ). P Expressions Grammar expr : | (expr) # ParenExpr | primitiveExpr # PrimitiveExpr | formatedString # FormatStringExpr | (tupleBody) # TupleExpr | (namedTupleBody) # NamedTupleExpr | expr.int # TupleAccessExpr | expr.iden # NamedTupleAccessExpr | expr[expr] # AccessExpr | keys(expr) # KeysExpr | values(expr) # ValuesExpr | sizeof(expr) # SizeofExpr | expr in expr # ContainsExpr | default(type) # DefaultExpr | new iden ( rvalueList? ) # NewExpr | iden ( rvalueList? ) # FunCallExpr | (- | !) expr # UnaryExpr | expr (* | / | + | -) expr # ArithBinExpr | expr (== | !=) expr # EqualityBinExpr | expr (&& | ||) expr # LogicalBinExpr | expr (< | > | >= | <= ) expr # CompBinExpr | expr as type # CastExpr | expr to type # CoerceExpr | choose ( expr? ) # ChooseExpr ; # Formated strings for creating strings formatedString | format ( StringLiteral (, rvalueList)? ) ; primitiveExpr : iden # Identifier | FloatLiteral # FloatConstant | BoolLiteral # BooleanConstant | IntLiteral # IntConstant | NullLiteral # Null | StringLiteral # StringConstant | $ # BooleanNonDeterministicChoice | halt # HaltEvent | this # SelfMachineReference ; # Body of a tuple tupleBody : | rvalue , | rvalue (, rvalue)+ ; # Body of a named tuple namedTupleBody: | iden = rvalue , | iden = rvalue (, iden = rvalue)+ ; # r-value is an expression that can\u2019t have a value assigned to it which # means r-value can appear on right but not on left hand side of an assignment operator(=) rvalue : expr ; # rvalueList is a comma separated list of rvalue. Primitives P allows the common primitive expressions like literal-constants for integers, floats, strings, booleans, and the null value. There are three unique primitive expressions in P: $ represents a nondeterministic boolean choice. It is a short hand for choose() which randomly returns a boolean value and the P Checker explores the behavior of the system for both the possibilities i.e., both when $ evaluates to true or false . halt is a special event in P used for destroying an instance of a P machine. The semantics of an halt event is that whenever a P machine throws an unhandled event exception because of a halt event then the machine is automatically destroyed or halted and all events sent to that machine instance are there after are equivalent to being dropped to ether. There are two ways of using the halt event: (1) self-halt by doing raise halt; raising a halt event which is not handled in the state machine or (2) by sending the halt event to the machine that needs to be halted. (Add reference to the Tutorial example). this represents the self machine reference of the current machine. It can be used to send self reference to other machines in the program so that they can send messages to this machine. Formatted String P allows creating formatted strings. Syntax: : format ( formatString (, rvalueList)? ) formatString is the format string and rvalueList is a comma separated list of arguments for the formatted string. Formatted String var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); hw = format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // hw value is \"Hello World, and tup value is 100!\" Print Formatted String Formatted strings are most useful for printing logs. Checkout print statement . var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); print format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // prints \"Hello World, and tup value is 100!\" Tuple and Named Tuple Values A tuple or named tuple value can be created using the following expressions: Syntax (tuple value): : (rvalue ,) for a single field tuple value or (rvalue (, rvalue)+) for tuple with multiple fields. // tuple value of type (int,) ( 10 ,) // tuple value of type (string, (string, string)) ( \"Hello\" , ( \"World\" , \"!\" )) // assume x: int and y: string // tuple value of type (int, string) ( x , y ) Syntax (named tuple value): : (iden = rvalue ,) for a single field named tuple value or (iden = rvalue (, iden = rvalue)+) for named tuple with multiple fields. // named tuple value of type (reqId: int,) ( reqId = 10 ,) // named tuple value of type (h: string, (w: string, a: string)) ( h = \"Hello\" , ( w = \"World\" , a = \"!\" )) // assume x: int and y: string // named tuple value of type (a:int, b:string) ( a = x , b = y ) Access Field of Tuple and Named Tuple The fields of a tuple can be accessed by using the . operation followed by the field index. Syntax (tuple value): expr.int where expr is the tuple value and int is the field index. // tuple with three fields var tupleEx : ( int , bool , int ); tupleEx = ( 20 , false , 21 ); // accessing the first and third element of the tupleEx tupleEx .0 = tupleEx .0 + tupleEx .2 ; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. Syntax (named tuple value) : expr.iden where expr is the named tuple value and iden is the field name. // named tuple with three fields var namedTupleEx : ( x1 : int , x2 : bool , x3 : int ); namedTupleEx = ( x1 = 20 , x2 = false , x3 = 21 ); // accessing the first and third element of the namedTupleEx namedTupleEx . x1 = namedTupleEx . x1 + namedTupleEx . x3 ; Indexing into a Collection P supports three collection types: map , seq , and set . We can index into these collection types to access its elements. Syntax: expr_c[expr_i] If expr_c is a value of sequence type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i . Similarly, If expr_c is a value of set type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i but not that for a set there is no guarantee for the order in which elements are stored in the set. Finally, if expr_c is a value of map type then expr_i represents the key to look up and expr_c[expr_i] represents the value for the key expr_i . Operations on Collections P supports four other operations on collection types: sizeof Syntax: : sizeof(expr) where expr is a value of type set , seq or map and it returns an integer value representing the size or length of the collection. var sq : seq [ int ] ; while ( i < sizeof ( sq ) > ) { ... i = i + 1 ; } keys and values Programmers can use keys and values functions to get access to a sequence of all the keys or values in map respectively. Syntax: : keys(expr) or values(expr) expr must be a map value, if expr : map[K, V] then keys(expr) returns a sequence of all keys in the map (of type seq[K] ) and similarly, values(expr) returns a sequence of all values in the map (of type seq[V] ). Primarily, keys and values are used to get contents of the map and then operate over it. contains (or in ) To check if an element (or key in the case of a map) belongs to a collection, P provides the in operation. Syntax: expr_e in expr_c expr_e is the element (or key in the case of map) and expr_c is the collection value. The in expression evaluates to true if the element belongs to the collection and false otherwise. var sq : seq [ tRequest ] ; var mp : map [ int , tRequest ] ; var rr : tRequest ; var i : int ; ... if ( rr in sq && rr in values ( mp ) && i in mp ) { ... } Default value for a type The default primitive in P can be used to obtain the default value for any type. Syntax: default(type) type is any P type and default(type) represents the default value for the type . The default values for all P types is provided here . New New expression is used to create an instance of a machine, new returns a machine reference to the newly created instance of the machine. Syntax : new iden (rvalue?) ; iden is the name of the machine to be create and rvalue is the optional constructor parameter that becomes the input parameter of the entry function of the start state of the machine. Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine. Function Call Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalueList? ) ; iden is the name of the function and rvalueList is the comma separated list of function arguments. Function call x = Foo (); y = Bar ( 10 , \"haha\" ); Negation and Not P supports two unary operations: - on integers and floats values (i.e., negation) and ! on boolean values(i.e., logical not). Arithmetic P supports the following arithmetic binary operations on integers or floats: + (i.e., addition), - (i.e., subtraction), * (i.e., multiplication), and / (i.e., division). Comparison P supports the following comparison binary operations on integers or floats: < (i.e., less-than), <= (i.e., less-than-equal), > (i.e., greator-than), and >= (i.e., greator-than-equal). Cast P supports two super types any and data ( more details ). To cast values from these supertypes to the actual types, P supports the as cast expression. Syntax: expr as T expr expression is cast to type T and if the cast is not valid then it leads to dynamic type-cast error. type tRecord = ( key : int , val : any ); ... var st : set [ tRecord ] ; var x : any ; var x_i : string ; var st_i : set [ ( key : int , val : string ) ] ; x_i = x as string ; st += (( key = 1 , val = \"hello\" )); st_i = st as set [ ( key : int , val : string ) ] ; ... Coerce P supports coercing of any value of type float to int and also any enum element to int . Syntax: expr to T expr expression is coerced to type T . We currently support only coercing of type float to int and also any enum element to int . enum Status { ERROR = 101 , SUCCESS = 102 } ... var x_f : float ; var x_i : int ; x_f = 101.0 ; x_i = x_f to int ; assert x_i == ERROR to int ; Choose P provides the choose primitive to model data nondeterminism in P programs. The P checker then explores the behavior of the program for all possible values that can be returned by the choose operation. Syntax: choose() or choose(expr) expr can either be a int value or a collection. For choose(x) , when x is an integer, choose(x) returns a random value between 0 to x (including x), when x is a collection then choose(x) returns a random element from the collection. choose () // returns true or false, is equivalent to $ choose ( 10 ) // returns an integer x, 0 <= x <= 10 choose ( x ) // if x is set or seq then returns a value from that collection The choose operation can be used to model nondeterministic environment machines that generate random inputs for the system. Another use case could be to model nondeterministic behavior within the system itself where the system can randomly choose to timeout or fail or drop messages . Performing a choose over an empty collection leads to an error. Also, choose from a map value returns a random key from the map.","title":"P Expressions"},{"location":"manual/expressions/#primitives","text":"P allows the common primitive expressions like literal-constants for integers, floats, strings, booleans, and the null value. There are three unique primitive expressions in P: $ represents a nondeterministic boolean choice. It is a short hand for choose() which randomly returns a boolean value and the P Checker explores the behavior of the system for both the possibilities i.e., both when $ evaluates to true or false . halt is a special event in P used for destroying an instance of a P machine. The semantics of an halt event is that whenever a P machine throws an unhandled event exception because of a halt event then the machine is automatically destroyed or halted and all events sent to that machine instance are there after are equivalent to being dropped to ether. There are two ways of using the halt event: (1) self-halt by doing raise halt; raising a halt event which is not handled in the state machine or (2) by sending the halt event to the machine that needs to be halted. (Add reference to the Tutorial example). this represents the self machine reference of the current machine. It can be used to send self reference to other machines in the program so that they can send messages to this machine.","title":"Primitives"},{"location":"manual/expressions/#formatted-string","text":"P allows creating formatted strings. Syntax: : format ( formatString (, rvalueList)? ) formatString is the format string and rvalueList is a comma separated list of arguments for the formatted string. Formatted String var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); hw = format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // hw value is \"Hello World, and tup value is 100!\" Print Formatted String Formatted strings are most useful for printing logs. Checkout print statement . var hw , h , w : string ; var tup : ( string , int ); h = \"Hello\" ; w = \"World\" ; tup = ( \"tup value\" , 100 ); print format ( \"{0} {1}, and {2} is {3}!\" , h , w , tup .0 , tup .1 ); // prints \"Hello World, and tup value is 100!\"","title":"Formatted String"},{"location":"manual/expressions/#tuple-and-named-tuple-values","text":"A tuple or named tuple value can be created using the following expressions: Syntax (tuple value): : (rvalue ,) for a single field tuple value or (rvalue (, rvalue)+) for tuple with multiple fields. // tuple value of type (int,) ( 10 ,) // tuple value of type (string, (string, string)) ( \"Hello\" , ( \"World\" , \"!\" )) // assume x: int and y: string // tuple value of type (int, string) ( x , y ) Syntax (named tuple value): : (iden = rvalue ,) for a single field named tuple value or (iden = rvalue (, iden = rvalue)+) for named tuple with multiple fields. // named tuple value of type (reqId: int,) ( reqId = 10 ,) // named tuple value of type (h: string, (w: string, a: string)) ( h = \"Hello\" , ( w = \"World\" , a = \"!\" )) // assume x: int and y: string // named tuple value of type (a:int, b:string) ( a = x , b = y )","title":"Tuple and Named Tuple Values"},{"location":"manual/expressions/#access-field-of-tuple-and-named-tuple","text":"The fields of a tuple can be accessed by using the . operation followed by the field index. Syntax (tuple value): expr.int where expr is the tuple value and int is the field index. // tuple with three fields var tupleEx : ( int , bool , int ); tupleEx = ( 20 , false , 21 ); // accessing the first and third element of the tupleEx tupleEx .0 = tupleEx .0 + tupleEx .2 ; Named tuples are similar to tuples with each field having an associated name. The fields of a named tuple can be accessed by using the . operation followed by the field name. Syntax (named tuple value) : expr.iden where expr is the named tuple value and iden is the field name. // named tuple with three fields var namedTupleEx : ( x1 : int , x2 : bool , x3 : int ); namedTupleEx = ( x1 = 20 , x2 = false , x3 = 21 ); // accessing the first and third element of the namedTupleEx namedTupleEx . x1 = namedTupleEx . x1 + namedTupleEx . x3 ;","title":"Access Field of Tuple and Named Tuple"},{"location":"manual/expressions/#indexing-into-a-collection","text":"P supports three collection types: map , seq , and set . We can index into these collection types to access its elements. Syntax: expr_c[expr_i] If expr_c is a value of sequence type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i . Similarly, If expr_c is a value of set type then expr_i must be an integer expression and expr_c[expr_i] represents the element at index expr_i but not that for a set there is no guarantee for the order in which elements are stored in the set. Finally, if expr_c is a value of map type then expr_i represents the key to look up and expr_c[expr_i] represents the value for the key expr_i .","title":"Indexing into a Collection"},{"location":"manual/expressions/#operations-on-collections","text":"P supports four other operations on collection types:","title":"Operations on Collections"},{"location":"manual/expressions/#sizeof","text":"Syntax: : sizeof(expr) where expr is a value of type set , seq or map and it returns an integer value representing the size or length of the collection. var sq : seq [ int ] ; while ( i < sizeof ( sq ) > ) { ... i = i + 1 ; }","title":"sizeof"},{"location":"manual/expressions/#keys-and-values","text":"Programmers can use keys and values functions to get access to a sequence of all the keys or values in map respectively. Syntax: : keys(expr) or values(expr) expr must be a map value, if expr : map[K, V] then keys(expr) returns a sequence of all keys in the map (of type seq[K] ) and similarly, values(expr) returns a sequence of all values in the map (of type seq[V] ). Primarily, keys and values are used to get contents of the map and then operate over it.","title":"keys and values"},{"location":"manual/expressions/#contains-or-in","text":"To check if an element (or key in the case of a map) belongs to a collection, P provides the in operation. Syntax: expr_e in expr_c expr_e is the element (or key in the case of map) and expr_c is the collection value. The in expression evaluates to true if the element belongs to the collection and false otherwise. var sq : seq [ tRequest ] ; var mp : map [ int , tRequest ] ; var rr : tRequest ; var i : int ; ... if ( rr in sq && rr in values ( mp ) && i in mp ) { ... }","title":"contains (or in)"},{"location":"manual/expressions/#default-value-for-a-type","text":"The default primitive in P can be used to obtain the default value for any type. Syntax: default(type) type is any P type and default(type) represents the default value for the type . The default values for all P types is provided here .","title":"Default value for a type"},{"location":"manual/expressions/#new","text":"New expression is used to create an instance of a machine, new returns a machine reference to the newly created instance of the machine. Syntax : new iden (rvalue?) ; iden is the name of the machine to be create and rvalue is the optional constructor parameter that becomes the input parameter of the entry function of the start state of the machine. Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine.","title":"New"},{"location":"manual/expressions/#function-call","text":"Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalueList? ) ; iden is the name of the function and rvalueList is the comma separated list of function arguments. Function call x = Foo (); y = Bar ( 10 , \"haha\" );","title":"Function Call"},{"location":"manual/expressions/#negation-and-not","text":"P supports two unary operations: - on integers and floats values (i.e., negation) and ! on boolean values(i.e., logical not).","title":"Negation and Not"},{"location":"manual/expressions/#arithmetic","text":"P supports the following arithmetic binary operations on integers or floats: + (i.e., addition), - (i.e., subtraction), * (i.e., multiplication), and / (i.e., division).","title":"Arithmetic"},{"location":"manual/expressions/#comparison","text":"P supports the following comparison binary operations on integers or floats: < (i.e., less-than), <= (i.e., less-than-equal), > (i.e., greator-than), and >= (i.e., greator-than-equal).","title":"Comparison"},{"location":"manual/expressions/#cast","text":"P supports two super types any and data ( more details ). To cast values from these supertypes to the actual types, P supports the as cast expression. Syntax: expr as T expr expression is cast to type T and if the cast is not valid then it leads to dynamic type-cast error. type tRecord = ( key : int , val : any ); ... var st : set [ tRecord ] ; var x : any ; var x_i : string ; var st_i : set [ ( key : int , val : string ) ] ; x_i = x as string ; st += (( key = 1 , val = \"hello\" )); st_i = st as set [ ( key : int , val : string ) ] ; ...","title":"Cast"},{"location":"manual/expressions/#coerce","text":"P supports coercing of any value of type float to int and also any enum element to int . Syntax: expr to T expr expression is coerced to type T . We currently support only coercing of type float to int and also any enum element to int . enum Status { ERROR = 101 , SUCCESS = 102 } ... var x_f : float ; var x_i : int ; x_f = 101.0 ; x_i = x_f to int ; assert x_i == ERROR to int ;","title":"Coerce"},{"location":"manual/expressions/#choose","text":"P provides the choose primitive to model data nondeterminism in P programs. The P checker then explores the behavior of the program for all possible values that can be returned by the choose operation. Syntax: choose() or choose(expr) expr can either be a int value or a collection. For choose(x) , when x is an integer, choose(x) returns a random value between 0 to x (including x), when x is a collection then choose(x) returns a random element from the collection. choose () // returns true or false, is equivalent to $ choose ( 10 ) // returns an integer x, 0 <= x <= 10 choose ( x ) // if x is set or seq then returns a value from that collection The choose operation can be used to model nondeterministic environment machines that generate random inputs for the system. Another use case could be to model nondeterministic behavior within the system itself where the system can randomly choose to timeout or fail or drop messages . Performing a choose over an empty collection leads to an error. Also, choose from a map value returns a random key from the map.","title":"Choose"},{"location":"manual/foriegntypesfunctions/","text":"","title":"P Foreign Interface"},{"location":"manual/functions/","text":"","title":"P Functions"},{"location":"manual/interface/","text":"","title":"Interface"},{"location":"manual/modulesystem/","text":"The P module system allows programmers to decompose their complex system into modules to implement and test the system compositionally. More details about the underlying theory for the P module system (assume-guarantee style compositional reasoning) is described in the paper In its simplest form, a module in P is a collection of state machines. The P module system allows constructing larger modules by composing or unioning modules together. Hence, a distributed system under test which is a composition of multiple components together can be constructed by composing (or unioning) modules corresponding to those components. The P test cases takes as input a module that represents the closed 1 system to be validated which is the union or composition of all the component modules. P Modules Grammar modExpr : | ( modExpr ) # AnnonymousModuleExpr | { bindExpr (, bindExpr)* } # PrimitiveModuleExpr | union modExpr (, modExpr)+ # UnionModuleExpr | assert idenList in modExpr # AssertModuleExpr | iden # NamedModule ; # Bind a machine to an interface bindExpr : (iden | iden -> iden) ; # MachineBindExpr # Create a named module i.e., assign a name to a module namedModuleDecl : module iden = modExpr ; # Named module declaration (Add a link to the client server and two phase commit example to describe this further). Named Module A named module declaration simply assigns a name to a module expression. Syntax : module mName = modExpr; mName is the assiged name for the module modExpr where modExpr is any of the modules described below. Named Module module serverModule = { Server, Timer }; The above line assigns the name serverModule to a primitive module consisting of machines Server and Timer . Primitive Module A primitive module is a (annonymous) collection of state machines. Syntax : { bindExpr (, bindExpr)* } where bindExpr is a binding expression which could either be just the name of a machine iden or a mapping mName -> iName that maps a machine mName to an interface iName . The binding enforces that whenever a machine iName is created in the module (i.e., new iName(..) ) it leads to the creation of machine mName . The indirection using this binding is helpful in cases where we would like to replace a machine with another machine (e.g., implementation by its abstraction). This usecase is explained in the ClientServer example (FixMe with a link). In most cases, a primitive module is simply a list of state machines that together implement that component. Primitive Module // Lets say there are three machines in the P program: Client, Server, and Timer module client = { Client }; module server = { Server, Timer }; client is a primitive module consisting of the Client machine and the server module is a primitive module consistency of machines Server and Timer . Primitive Module with Bindings // Lets say there are four machines in the P program: Client, Server, AbstractServer and Timer module client = { Client }; module server = { Server, Timer }; module serverAbs = {Server -> AbstractServer, Timer}; client is a primitive module consisting of the Client machine and the server module is a primitive module consistency of machines Server and Timer . The module serverAbs represents a primitive module consistency of machines AbstractServer and Timer machines with the difference that wherever the serverAbs module is used the creation of machine Server will in turn lead to creation of the AbstractServer machine. Union Module P supports unioning multiple modules together to create larger, more complex modules. The idea is to implement the distributed system as a collection of components (modules), test and verify these components in isolation using the abstractions of other components, and also potentially union them together to validate the entire system together as well. Syntax: : union modExpr (, modExpr)+ modExpr is any P module. The union of two modules is simply a creation of a new module which is a union of the machines of the component modules. module system = (union client, server); system is a module which is a union of the modules client and server . module systemAbs = (union client, serverAbs); systemAbs is a module which is a union of the module client and the serverAbs where the Client machine interacts with the AbstractServer machine instead of the Server machine in the system module. Assert Monitors Module P allows attaching monitors (or specifications) to modules. When attaching monitors to a module, the events observed by the monitors must be sent by some machine in the module. The way to think about assert monitors module is that: testing this module asserts that each execution of the module satisfies the global properties specified by the monitors. Syntax: assert idenList in modExpr idenList is a comma separated list of monitor (spec machine) names that are being asserted on the executions of the module modExpr . assert AtomicitySpec, EventualResponse in TwoPhaseCommit The above module asserts that the executions of the module TwoPhaseCommit satisfy the properties specified by the monitors AtomicitySpec and EventualResponse . More module constructors P supports more complex module constructors like compose , hide , and rename . The description for these will be added later, they are mostly used for more advanced compositional reasoning. A closed system is a system where all the machines or interfaces that are created are defined or implemented in the unioned modules. \u21a9","title":"P Module System"},{"location":"manual/modulesystem/#named-module","text":"A named module declaration simply assigns a name to a module expression. Syntax : module mName = modExpr; mName is the assiged name for the module modExpr where modExpr is any of the modules described below. Named Module module serverModule = { Server, Timer }; The above line assigns the name serverModule to a primitive module consisting of machines Server and Timer .","title":"Named Module"},{"location":"manual/modulesystem/#primitive-module","text":"A primitive module is a (annonymous) collection of state machines. Syntax : { bindExpr (, bindExpr)* } where bindExpr is a binding expression which could either be just the name of a machine iden or a mapping mName -> iName that maps a machine mName to an interface iName . The binding enforces that whenever a machine iName is created in the module (i.e., new iName(..) ) it leads to the creation of machine mName . The indirection using this binding is helpful in cases where we would like to replace a machine with another machine (e.g., implementation by its abstraction). This usecase is explained in the ClientServer example (FixMe with a link). In most cases, a primitive module is simply a list of state machines that together implement that component. Primitive Module // Lets say there are three machines in the P program: Client, Server, and Timer module client = { Client }; module server = { Server, Timer }; client is a primitive module consisting of the Client machine and the server module is a primitive module consistency of machines Server and Timer . Primitive Module with Bindings // Lets say there are four machines in the P program: Client, Server, AbstractServer and Timer module client = { Client }; module server = { Server, Timer }; module serverAbs = {Server -> AbstractServer, Timer}; client is a primitive module consisting of the Client machine and the server module is a primitive module consistency of machines Server and Timer . The module serverAbs represents a primitive module consistency of machines AbstractServer and Timer machines with the difference that wherever the serverAbs module is used the creation of machine Server will in turn lead to creation of the AbstractServer machine.","title":"Primitive Module"},{"location":"manual/modulesystem/#union-module","text":"P supports unioning multiple modules together to create larger, more complex modules. The idea is to implement the distributed system as a collection of components (modules), test and verify these components in isolation using the abstractions of other components, and also potentially union them together to validate the entire system together as well. Syntax: : union modExpr (, modExpr)+ modExpr is any P module. The union of two modules is simply a creation of a new module which is a union of the machines of the component modules. module system = (union client, server); system is a module which is a union of the modules client and server . module systemAbs = (union client, serverAbs); systemAbs is a module which is a union of the module client and the serverAbs where the Client machine interacts with the AbstractServer machine instead of the Server machine in the system module.","title":"Union Module"},{"location":"manual/modulesystem/#assert-monitors-module","text":"P allows attaching monitors (or specifications) to modules. When attaching monitors to a module, the events observed by the monitors must be sent by some machine in the module. The way to think about assert monitors module is that: testing this module asserts that each execution of the module satisfies the global properties specified by the monitors. Syntax: assert idenList in modExpr idenList is a comma separated list of monitor (spec machine) names that are being asserted on the executions of the module modExpr . assert AtomicitySpec, EventualResponse in TwoPhaseCommit The above module asserts that the executions of the module TwoPhaseCommit satisfy the properties specified by the monitors AtomicitySpec and EventualResponse . More module constructors P supports more complex module constructors like compose , hide , and rename . The description for these will be added later, they are mostly used for more advanced compositional reasoning. A closed system is a system where all the machines or interfaces that are created are defined or implemented in the unioned modules. \u21a9","title":"Assert Monitors Module"},{"location":"manual/monitors/","text":"Programmers can write safety and liveness specifications in P as monitors or spec machines. spec machines are monitor state machines or observer state machines that observe a set of events during the execution of the system and assert the desired correctness specifications based on these observations. Machines vs Spec Machine Syntactically, machines and spec machines in P are very similar in terms of the state machine structure . But, they have some key differences: spec machines in P are observer machines (imagine runtime monitors), they observe a set of events in the execution of the system and based on these observed events (may keep track on local state) it asserts the desired global safety and liveness specifications. Since spec machines are observer machines, they cannot have any side effects on the system behavior and hence, spec machines cannot perform send , receive , new , and annouce . spec machines are global machines , in other words, there is only a single instance of each monitor created at the start of the execution of the system. We currently do not support dynamic creation of monitors. Hence, spec machines cannot use this expression. spec machines are synchronously composed with the system that it is monitoring. The way this is acheived is: each time there is a send or announce of an event during the execution of a system, all the monitors or specifications that are observing that event are executed synchronously at that point. Another way to imagine this is: just before send or annouce of an event, we deliver this event to all the monitors that are observing the event and synchronously execute the monitor at that point. Finally, spec machines can have hot and cold annotations on its states to model liveness specifiations. P Spec Machine Grammar specMachineDecl : spec iden observes eventsList statemachineBody ; As mentioned above, syntactically, the P spec machines are very similar to the P state machines . The main difference being the observes annotation that specifies the list of events being observed (monitored) and also the hot and cold annotations on the states of a liveness specification. Syntax: spec iden observes eventsList statemachineBody ; iden is the name of the spec machine, eventsList is the comma separated list of events observed by the spec machine and the statemachineBody is the implementation of the specification and its grammar is similar to the P state machine . Safety specification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /******************************************************************* ReqIdsAreMonotonicallyIncreasing observes the eRequest event and checks that the payload (Id) associated with the requests sent by all concurrent clients in the system is always globally monotonically increasing by 1 *******************************************************************/ spec ReqIdsAreMonotonicallyIncreasing observes eRequest { // keep track of the Id in the previous request var previousId : int ; start state Init { on eRequest do ( req : tRequest ) { assert req . rId > previousId , format ( \"Request Ids not monotonically increasing, got {0}, previously seen Id was { 1 } \", req.rId, previousId); previousId = req . rId ; } } } The above specifications checks a very simple global invariant that all eRequest events that are being sent by clients in the system have a globally monotonically increasing rId s. Liveness specification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /************************************************************************** GuaranteedProgress observes the eRequest and eResponse events, it asserts that every request is always responded by a successful response. ***************************************************************************/ spec GuaranteedProgress observes eRequest , eResponse { // keep track of the pending requests var pendingReqs : set [ int ]; start state NopendingRequests { on eRequest goto PendingReqs with ( req : tRequest ){ pendingReqs += ( req . rId ); } } hot state PendingReqs { on eResponse do ( resp : tResponse ) { assert resp . rId in pendingReqs , format ( \"unexpected rId: {0} received, expected one of {1}\" , resp . rId , pendingReqs ); if ( resp . status == SUCCESS ) { pendingReqs -= ( resp . rId ); if ( sizeof ( pendingReqs ) == 0 ) // requests already responded goto NopendingRequests ; } } on eRequest goto PendingReqs with ( req : tRequest ){ pendingReqs += ( req . rId ); } } } The above specification checks the global liveness property that every event eRequest is eventually followed by a corresponding successful eResponse event. The key idea is that the system satisfies a liveness specification if at the end of the execution the monitor is not in a hot state (line 13). The programmers can use hot annotation on states to mark them as intermediate or error states. Hence, properties like eventually something holds or every event X is eventually followed by Y or eventually the system enters a convergence state , all such properties can be specified by marking the intermediate state as hot states and the checker ensures that all the executions of the system eventually end in a non-hot state. Details about the importance of liveness specifications and how we check if the system satisfies these properties is described here .","title":"P Monitors"},{"location":"manual/statemachines/","text":"","title":"P State Machines"},{"location":"manual/statements/","text":"A Function in P can be arbitrary piece of imperative code which enables programmers to capture complex protocol logic in their state machines. P supports common imperative programming language statement constructs like while-loops, function calls, and conditionals. P Statements Grammar statement : { statement* } # CompoundStmt | assert expr (, expr)? ; # AssertStmt | print expr ; # PrintStmt | while ( expr ) statement # WhileStmt | if ( expr ) statement (else statement)? # IfThenElseStmt | break ; # BreakStmt | continue ; # ContinueStmt | return expr? ; # ReturnStmt | lvalue = rvalue ; # AssignStmt | lvalue += ( expr, rvalue ) ; # InsertStmt | lvalue += ( rvalue ) ; # AddStmt | lvalue -= rvalue ; # RemoveStmt | new iden (rvalue?) ; # CtorStmt | iden ( rvalueList? ) ; # FunCallStmt | raise expr (, rvalue)? ; # RaiseStmt | send expr, expr (, rvalue)? ; # SendStmt | annouce expr (, rvalue)? ; # AnnounceStmt | goto iden (, rvalue)? ; # GotoStmt | receive { recvCase+ } # ReceiveStmt ; /** l-value may appear as left hand of an assignment operator(=) **/ lvalue : name=iden # VarLvalue | lvalue . field=iden # NamedTupleFieldAccess | lvalue . int # TupleFieldAccess | lvalue [ expr ] # CollectionLookUp ; /* A r-value is an expression that can\u2019t have a value assigned to it which means r-value can appear on right but not on left hand side of an assignment operator(=)*/ rvalue : expr ; # rvalueList is a comma separated list of rvalue. /* case block inside a receive statement */ recvCase : case eventList : anonFunction The expr is any expression in P defined by the grammar desbribed in P Expressions Assert P allows writing local assertions using the assert statement. If the program violates the assertion then a counter example is generated by the P checker. Syntax : assert expr (, expr)? ; The assert statement must have a boolean expression followed by an optional string message that is printed in the error trace. Assert assert ( requestId > 1 ) && ( requestId in allRequestsSet ); Assert that the requestId is always greater than 1 and is in the set of all requests. Assert with Error Message assert x >= 0 , \"Expected x to be always positive\" ; The assert statement can have a string message which is printed in the error trace. Assert with Formatted Error Message assert ( requestId in allRequestsSet ), format ( \"requestId {0} is not in the requests set = {1}\" , requestId , allRequestsSet ); Assert that the requestId is in the set of all requests. You can also provide a formatted string error message to add details to the error message generated. Print Print statements can be used for writing or printing log messages into the error traces (especially for debugging purposes). Syntax : print expr ; The print statement must have an expression of type string . Print Simple Message print \"Hello World!\" ; Print \"Hello World!\" in the execution trace log. Print Formatted String Message x = \"You\" ; print format ( \"Hello World to {0}!!\" , x ); Print \"Hello World to You!!\" in the execution trace log. While While statement in P is just like while loops in other popular programming languages like C, C# or Java. Syntax : while ( expr ) statement expr is the conditional boolean expression and statement could be any P statement. While Loop i = 0 ; while ( i < 10 ) { ... i = i + 1 ; } While loop iterating over collection i = 0 ; while ( i < sizeof ( s )) { ... print s [ i ]; i = i + 1 ; } If Then Else IfThenElse statement in P is just like conditional if statements in other popular programming languages like C, C# or Java. Syntax : if ( expr ) statement (else statement)? expr is the conditional boolean expression and statement could be any P statement. The else block is optional. If Statement if ( x > 10 ) { ... x = x + 20 ; } If Else Statement if ( x > 10 ) { x = 0 ; } else { x = x + 1 ; } Break and Continue break and continue statements in P are just like in other popular programming languages like C, C# or Java to break out of the while loop or to continue to the next iteration of the loop respectively. Break while ( true ) { ... if ( x == 10 ) break ; ... x = x + 1 ; } Continue while ( true ) { ... if ( x == 10 ) // skip the loop when x is 10 continue ; ... } Return return statement in P can be used to return (or return a value) from any function. Return fun IncrementX () { if ( x > MAX_INT ) return ; x = x + 1 ; } Return Value fun Max ( x : int , y : int ) : int { if ( x > y ) return x ; else return y ; } Assignment Value Semantics Recollect that P has value semantics or copy-by-value semantics and does not support any notion of references. Syntax : lvalue = rvalue ; Note that because of value semantics assignment in P copies the value of the rvalue into lvalue . lvalue could be any variable, a tuple field access, or an element in a collection as described in the Grammar above. rvalue could be any expression that evaluates to the same type as lvalue . Assignment is copying! var a : seq [ string ]; var b : seq [ string ]; b += ( 0 , \"b\" ); a = b ; // copy value a += ( 1 , \"a\" ); print a ; // will print [\"b\", \"a\"] print b ; // will print [\"a\"] Assignments .. a = 10 ; s [ i ] = 20 ; tup1 . a = \"x\" ; tup2 . 0 = 10 ; t = foo (); Insert Insert statement is used to insert or add an element into a collection. Syntax : lvalue += ( expr, rvalue ) ; or lvalue += ( rvalue ) ; lvalue is a value of any collection type in P. Insert into a Sequence var sq : seq [ T ]; var x : T , i : int ; // add x into the sequence sq at index i sq += ( i , x ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) . i = 0 insserts x at the start of sq and i = sizeof(sq) appends x at the end of sq Insert into a map or update map var mp : map [ K , V ]; var x : K , y : V ; // adds (x, y) into the map mp += ( x , y ); // adds (x, y) into the map, if key x already exists then updates its value to y. mp [ x ] = y ; Insert or add into a set var st : set [ T ]; var x : T ; // adds x into the set st st += ( x ); Remove Remove statement is used to remove an element from a collection. Syntax : lvalue -= rvalue ; Remove from a Sequence var sq : seq [ T ]; var i : int ; // remove element at index i in the sequence sq sq -= ( i ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) - 1 . Remove from a map var mp : map [ K , V ]; var x : K ; // Removes the element (x, _) from the map i.e., removes the element with key x from mp mp -= ( x ); Remove from a set var st : set [ T ]; var x : T ; // removes x from the set st st -= ( x ); New New statement is used to create an instance of a machine in P. Syntax : new iden (rvalue?) ; Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine. Function Call Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalue? ) ; Function call Foo (); Bar ( 10 , \"haha\" ); Raise The statement raise e, v; terminates the evaluation of the function raising an event e with payload v . The control of the state machine jumps to end of the entry function (popping the function stack if raise is trigger inside a nested function), and the state machine immediately handles the raised event. One can think of raise of an event as throwing an exception which terminates the execution of the function stack and must be immediately handled by the event-handlers defined in that state. Syntax : raise expr (, rvalue)? Raise Event state HandleRequest { entry ( req : tRequest ) { // ohh, this is a Add request and I have a event handler for it if ( req . type == \"Add\" ) raise eAddOperation , req . Transaction ; // terminates function ..... ..... assert req . type != \"Add\" ; // valid } on eAddOperation do ( trans : tTransaction ) { ... } } Non deterministically triggering event handlers internally state DoAddOrRemove { entry { /* I am uncertain, at this point I may want to trigger a Add or Substract event-handler without sending an event to self which will be enqueued and then dequeued in FIFO order I want to immediately execute this handlers before anything else */ if ( $ ) raise eAddOperation , transaction ; // terminates function else raise eRemoveOperation , transaction ; // terminates function assert false ; // valid, as this is unreachable } on eAddOperation do ( trans : tTransaction ) { ... } on eRemoveOperation do ( trans : tTransaction ) { ... } } Send Send statement is one of the most important statements in P as it is used to send messages to other state machines . Send takes as argument a triple send t, e, v , where t is a reference to the target state machine, e is the event sent and v is the associated payload. Syntax : send expr, expr (, rvalue)? ; Sends in P are asynchronous and non-blocking. Statement send t, e, v enqueues the event e with payload v into the target machine t 's message buffer. Send event with payload send server , eRequest , ( source = this , reqId = 0 ); Send event send server , ePing ; Announce Announce is used to publish messages to specification monitors in P. When writing specifications there are instances when we would like to send additional information to monitors that is not captured in the events exchanged between state machines. Recollect that spec monitors in P follow a publish-subscribe model of communication. Each monitor observes a set of events and whenever a machine sends an event that is in the observes set of a monitor then it is synchronously delivered to the monitor. Announce can be used to publish an event to all the monitors that are observing that event. The Two phase commit example provides an use case for announce. Syntax : annouce expr (, rvalue)? ; Announce event spec CheckConvergedState observes eStateUpdate , eSystemConverged { ... } Consider a specification monitor that continuously observes eStateUpdate event to keep track of the system state and then asserts the required property when the system converges. We can use an announce statement to inform the monitor when the system has converged and we should to assert the global specification. announce eSystemConverged, payload; Note Announce only delivers events to specification monitors (not state machines) and hence has no side effect on the system behavior. Announce is used for passing information to the monitors during system execution which the monitors can use to assert global specifications about the system. Goto Goto statement can be used to jump to a particular state. On executing a goto, the state machine exits the current state (terminating the execution of the current function) and enters the target state. The optional payload accompanying the goto statement becomes the input parameter to the entry function of the target state. Syntax : goto iden (, rvalue)? ; Goto state ServicePendingRequests { entry { if ( sizeof ( pendingRequests ) == 0 ) goto Done ; // process requests .... } } state Done { ... } Goto with payload state ServiceRequests { entry ( req : tRequest ) { // process request with some complicated logic ... lastReqId = req . Id ; goto WaitForRequests , lastReqId ; } } state WaitForRequests { entry ( lastReqId : int ) { ... } } Receive Receive statements in P are used to perform blocking await/receive for a set of events inside a function. Syntax : ``` receive { recvCase+ } /* case block inside a receive statement */ recvCase : case eventList : anonFunction ``` Each receive statement can block or wait on a set of events, all other events are automatically deferred by the state machine. On receiving an event that the receive is blocking on (case blocks), the state machine unblocks, executes the corresponding case-handler and resumes executing the next statement after receive. Receive: await single event fun AcquireLock ( lock : machine ) { send lock , eAcquireLock ; receive { case eLockGranted : ( result : tResponse ) { /* case handler */ } } print \"Lock Acquired!\" } Note that when executing the AcquireLock function the state machine blocks at the receive statement, it automatically defers all the events except the eLockGranted event. On receiving the eLockGranted , the case-handler is executed and then the print statement. Receive: await multiple events fun WaitForTime ( timer : Timer , time : int ) { var success : bool ; send timer , eStartTimer , time ; receive { case eTimeOut : { success = true ; } case eStartTimerFailed : { success = false ; } } if ( success ) print \"Successfully waited!\" } Note that when executing the WaitForTime function the state machine blocks at the receive statement, it automatically defers all the events except the eTimeOut and eStartTimerFailed events.","title":"P Statements"},{"location":"manual/statements/#assert","text":"P allows writing local assertions using the assert statement. If the program violates the assertion then a counter example is generated by the P checker. Syntax : assert expr (, expr)? ; The assert statement must have a boolean expression followed by an optional string message that is printed in the error trace. Assert assert ( requestId > 1 ) && ( requestId in allRequestsSet ); Assert that the requestId is always greater than 1 and is in the set of all requests. Assert with Error Message assert x >= 0 , \"Expected x to be always positive\" ; The assert statement can have a string message which is printed in the error trace. Assert with Formatted Error Message assert ( requestId in allRequestsSet ), format ( \"requestId {0} is not in the requests set = {1}\" , requestId , allRequestsSet ); Assert that the requestId is in the set of all requests. You can also provide a formatted string error message to add details to the error message generated.","title":"Assert"},{"location":"manual/statements/#print","text":"Print statements can be used for writing or printing log messages into the error traces (especially for debugging purposes). Syntax : print expr ; The print statement must have an expression of type string . Print Simple Message print \"Hello World!\" ; Print \"Hello World!\" in the execution trace log. Print Formatted String Message x = \"You\" ; print format ( \"Hello World to {0}!!\" , x ); Print \"Hello World to You!!\" in the execution trace log.","title":"Print"},{"location":"manual/statements/#while","text":"While statement in P is just like while loops in other popular programming languages like C, C# or Java. Syntax : while ( expr ) statement expr is the conditional boolean expression and statement could be any P statement. While Loop i = 0 ; while ( i < 10 ) { ... i = i + 1 ; } While loop iterating over collection i = 0 ; while ( i < sizeof ( s )) { ... print s [ i ]; i = i + 1 ; }","title":"While"},{"location":"manual/statements/#if-then-else","text":"IfThenElse statement in P is just like conditional if statements in other popular programming languages like C, C# or Java. Syntax : if ( expr ) statement (else statement)? expr is the conditional boolean expression and statement could be any P statement. The else block is optional. If Statement if ( x > 10 ) { ... x = x + 20 ; } If Else Statement if ( x > 10 ) { x = 0 ; } else { x = x + 1 ; }","title":"If Then Else"},{"location":"manual/statements/#break-and-continue","text":"break and continue statements in P are just like in other popular programming languages like C, C# or Java to break out of the while loop or to continue to the next iteration of the loop respectively. Break while ( true ) { ... if ( x == 10 ) break ; ... x = x + 1 ; } Continue while ( true ) { ... if ( x == 10 ) // skip the loop when x is 10 continue ; ... }","title":"Break and Continue"},{"location":"manual/statements/#return","text":"return statement in P can be used to return (or return a value) from any function. Return fun IncrementX () { if ( x > MAX_INT ) return ; x = x + 1 ; } Return Value fun Max ( x : int , y : int ) : int { if ( x > y ) return x ; else return y ; }","title":"Return"},{"location":"manual/statements/#assignment","text":"Value Semantics Recollect that P has value semantics or copy-by-value semantics and does not support any notion of references. Syntax : lvalue = rvalue ; Note that because of value semantics assignment in P copies the value of the rvalue into lvalue . lvalue could be any variable, a tuple field access, or an element in a collection as described in the Grammar above. rvalue could be any expression that evaluates to the same type as lvalue . Assignment is copying! var a : seq [ string ]; var b : seq [ string ]; b += ( 0 , \"b\" ); a = b ; // copy value a += ( 1 , \"a\" ); print a ; // will print [\"b\", \"a\"] print b ; // will print [\"a\"] Assignments .. a = 10 ; s [ i ] = 20 ; tup1 . a = \"x\" ; tup2 . 0 = 10 ; t = foo ();","title":"Assignment"},{"location":"manual/statements/#insert","text":"Insert statement is used to insert or add an element into a collection. Syntax : lvalue += ( expr, rvalue ) ; or lvalue += ( rvalue ) ; lvalue is a value of any collection type in P. Insert into a Sequence var sq : seq [ T ]; var x : T , i : int ; // add x into the sequence sq at index i sq += ( i , x ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) . i = 0 insserts x at the start of sq and i = sizeof(sq) appends x at the end of sq Insert into a map or update map var mp : map [ K , V ]; var x : K , y : V ; // adds (x, y) into the map mp += ( x , y ); // adds (x, y) into the map, if key x already exists then updates its value to y. mp [ x ] = y ; Insert or add into a set var st : set [ T ]; var x : T ; // adds x into the set st st += ( x );","title":"Insert"},{"location":"manual/statements/#remove","text":"Remove statement is used to remove an element from a collection. Syntax : lvalue -= rvalue ; Remove from a Sequence var sq : seq [ T ]; var i : int ; // remove element at index i in the sequence sq sq -= ( i ); Index for a sequence The value of index i above should be between 0 <= i <= sizeof(sq) - 1 . Remove from a map var mp : map [ K , V ]; var x : K ; // Removes the element (x, _) from the map i.e., removes the element with key x from mp mp -= ( x ); Remove from a set var st : set [ T ]; var x : T ; // removes x from the set st st -= ( x );","title":"Remove"},{"location":"manual/statements/#new","text":"New statement is used to create an instance of a machine in P. Syntax : new iden (rvalue?) ; Create a machine new Client (( id = 1 , server = this )); Creates a dynamic instance of a Client machine and passes the constructor parameter (id = 1, server = this) which is delivered as a payload to the entry function of the start state of the created Client machine.","title":"New"},{"location":"manual/statements/#function-call","text":"Function calls in P are similar to any other imperative programming languages. Note that the parameters passed to the functions and the return values are pass-by-value! Syntax : iden ( rvalue? ) ; Function call Foo (); Bar ( 10 , \"haha\" );","title":"Function Call"},{"location":"manual/statements/#raise","text":"The statement raise e, v; terminates the evaluation of the function raising an event e with payload v . The control of the state machine jumps to end of the entry function (popping the function stack if raise is trigger inside a nested function), and the state machine immediately handles the raised event. One can think of raise of an event as throwing an exception which terminates the execution of the function stack and must be immediately handled by the event-handlers defined in that state. Syntax : raise expr (, rvalue)? Raise Event state HandleRequest { entry ( req : tRequest ) { // ohh, this is a Add request and I have a event handler for it if ( req . type == \"Add\" ) raise eAddOperation , req . Transaction ; // terminates function ..... ..... assert req . type != \"Add\" ; // valid } on eAddOperation do ( trans : tTransaction ) { ... } } Non deterministically triggering event handlers internally state DoAddOrRemove { entry { /* I am uncertain, at this point I may want to trigger a Add or Substract event-handler without sending an event to self which will be enqueued and then dequeued in FIFO order I want to immediately execute this handlers before anything else */ if ( $ ) raise eAddOperation , transaction ; // terminates function else raise eRemoveOperation , transaction ; // terminates function assert false ; // valid, as this is unreachable } on eAddOperation do ( trans : tTransaction ) { ... } on eRemoveOperation do ( trans : tTransaction ) { ... } }","title":"Raise"},{"location":"manual/statements/#send","text":"Send statement is one of the most important statements in P as it is used to send messages to other state machines . Send takes as argument a triple send t, e, v , where t is a reference to the target state machine, e is the event sent and v is the associated payload. Syntax : send expr, expr (, rvalue)? ; Sends in P are asynchronous and non-blocking. Statement send t, e, v enqueues the event e with payload v into the target machine t 's message buffer. Send event with payload send server , eRequest , ( source = this , reqId = 0 ); Send event send server , ePing ;","title":"Send"},{"location":"manual/statements/#announce","text":"Announce is used to publish messages to specification monitors in P. When writing specifications there are instances when we would like to send additional information to monitors that is not captured in the events exchanged between state machines. Recollect that spec monitors in P follow a publish-subscribe model of communication. Each monitor observes a set of events and whenever a machine sends an event that is in the observes set of a monitor then it is synchronously delivered to the monitor. Announce can be used to publish an event to all the monitors that are observing that event. The Two phase commit example provides an use case for announce. Syntax : annouce expr (, rvalue)? ; Announce event spec CheckConvergedState observes eStateUpdate , eSystemConverged { ... } Consider a specification monitor that continuously observes eStateUpdate event to keep track of the system state and then asserts the required property when the system converges. We can use an announce statement to inform the monitor when the system has converged and we should to assert the global specification. announce eSystemConverged, payload; Note Announce only delivers events to specification monitors (not state machines) and hence has no side effect on the system behavior. Announce is used for passing information to the monitors during system execution which the monitors can use to assert global specifications about the system.","title":"Announce"},{"location":"manual/statements/#goto","text":"Goto statement can be used to jump to a particular state. On executing a goto, the state machine exits the current state (terminating the execution of the current function) and enters the target state. The optional payload accompanying the goto statement becomes the input parameter to the entry function of the target state. Syntax : goto iden (, rvalue)? ; Goto state ServicePendingRequests { entry { if ( sizeof ( pendingRequests ) == 0 ) goto Done ; // process requests .... } } state Done { ... } Goto with payload state ServiceRequests { entry ( req : tRequest ) { // process request with some complicated logic ... lastReqId = req . Id ; goto WaitForRequests , lastReqId ; } } state WaitForRequests { entry ( lastReqId : int ) { ... } }","title":"Goto"},{"location":"manual/statements/#receive","text":"Receive statements in P are used to perform blocking await/receive for a set of events inside a function. Syntax : ``` receive { recvCase+ } /* case block inside a receive statement */ recvCase : case eventList : anonFunction ``` Each receive statement can block or wait on a set of events, all other events are automatically deferred by the state machine. On receiving an event that the receive is blocking on (case blocks), the state machine unblocks, executes the corresponding case-handler and resumes executing the next statement after receive. Receive: await single event fun AcquireLock ( lock : machine ) { send lock , eAcquireLock ; receive { case eLockGranted : ( result : tResponse ) { /* case handler */ } } print \"Lock Acquired!\" } Note that when executing the AcquireLock function the state machine blocks at the receive statement, it automatically defers all the events except the eLockGranted event. On receiving the eLockGranted , the case-handler is executed and then the print statement. Receive: await multiple events fun WaitForTime ( timer : Timer , time : int ) { var success : bool ; send timer , eStartTimer , time ; receive { case eTimeOut : { success = true ; } case eStartTimerFailed : { success = false ; } } if ( success ) print \"Successfully waited!\" } Note that when executing the WaitForTime function the state machine blocks at the receive statement, it automatically defers all the events except the eTimeOut and eStartTimerFailed events.","title":"Receive"},{"location":"manual/testcases/","text":"P Test cases are used to define different finite scenarios under which we would like to check the correctness of our system. P Test Cases Grammar testcase | test iden [main=iden] : modExpr ; # TestDecl ; modExpr represent the P module defined using the module expressions described in P Module System Test Declaration P allows the programmers to write different finite model checking scenarios that check the correctness of the module (or system) under test. The system module to be tested is unioned with different environment modules (or test harnesses) to check its correctness under different inputs scenarios generated by the environment modules. Each test case is automatically discharged by the P Checker. Syntax: : test tName [main=mName] : module_under_test ; tName is the name of the test case, mName is the name of the main machine where the execution of the system starts, and module_under_test is the module to be tested. Properties checked for a Test Case For each testcase, the P checker by default asserts that for each execution of the system (or module_under_test ): (1) there are no unhandled event exceptions, (2) all local assertions in the program hold, (3) there are no deadlocks and finally (4) based on the specification monitors that are attached to the module, the safety and liveness properties asserted by the monitors always hold.","title":"P Test cases"},{"location":"manual/testcases/#test-declaration","text":"P allows the programmers to write different finite model checking scenarios that check the correctness of the module (or system) under test. The system module to be tested is unioned with different environment modules (or test harnesses) to check its correctness under different inputs scenarios generated by the environment modules. Each test case is automatically discharged by the P Checker. Syntax: : test tName [main=mName] : module_under_test ; tName is the name of the test case, mName is the name of the main machine where the execution of the system starts, and module_under_test is the module to be tested. Properties checked for a Test Case For each testcase, the P checker by default asserts that for each execution of the system (or module_under_test ): (1) there are no unhandled event exceptions, (2) all local assertions in the program hold, (3) there are no deadlocks and finally (4) based on the specification monitors that are attached to the module, the safety and liveness properties asserted by the monitors always hold.","title":"Test Declaration"},{"location":"tutorial/clientserver/","text":"A P program is a collection of event and machine declarations. Here is a basic P program containing a Client machine and a Server machine communicating with each other via Ping and Pong events. --8<--\u200b \"Client.p\" We now take a closer look at the event and machine declarations in this program. The declaration of event PING indicates that it is accompanied with a data value of machine type. The machine type contains the addresses of all dynamically-created P machines. This declaration also indicates that at most one instance of the PING event may be present in the input queue of any machine. A machine declaration contains a collection of variable and state declarations. For example, the machine Client has a variable server and three states, Init , SendPing , and WaitPong , declared inside it. The storage for the server variable is local to a particular instance of the Client machine. State Init is declared to be the start state to indicate that an instance of Client begins executing by entering the Init state. There can be many different declarations inside a state. A code block indicated by entry { ... } is executed when the state is entered. Similarly, a code block indicated by exit { ... } (not used in our example) is executed when the state is exited. Other than these two declarations, all other declarations inside a state are related to event handling. The declaration on SUCCESS goto SendPing in state Init is an example of such a declaration indicating that the SUCCESS event must be handled by moving to state SendPing . Different states can choose to handle a particular event differently. For example, state Init handles SUCCESS by moving to state SendPing but state SendPing handled SUCCESS by moving to state WaitPong . Next, we look at the contents of the entry code block in state Init of machine Client . This code block has two statements. The first statement creates an instance of the Server machine and stores the address of this instance in variable server . The second statement raises an event SUCCESS which causes control to exit Init and enter SendPing . In P, when a machine sends an event to another machine (or itself), the event is enqueued in the target machine's input queue. However, a raised event does not go through the queue; rather it terminates execution of the enclosing code block and is handled immediately. The entry code block in state SendPing shows an example of the \"send\" statement for sending a PING event to the machine whose address is stored in the variable server. The keyword this evaluates to the address of the machine executing the current statement. Finally, the entry code block in state SendPong of machine Server shows that the data value associated with a received event can be retrieved through a parameter of the apppriate type to the event handler. In this code block, the payload parameter evaluates to the data attached to the PING event whose handling caused control to enter SendPong . This data value is the address of the instance of the Client machine that sent the PING event. Similarly, a parameter can be used to retrieve the argument to the constructor of a freshly-created machine when it starts execution in the entry block of its start state. The attentive reader might be wondering how the PingPong program begins execution. The machine Client is annotated with main to indicate that program execution begins with a single instance of Client entering state Init . Let us call this Client instance X. X creates an instance of Server and raises SUCCESS to enter state SendPing . Let us call this Server instance Y; it begins execution in state WaitPing of Server . From this point on, X and Y exchange PING and PONG messages, where X cycles between SendPing and WaitPong and Y cycles between WaitPing and SendPong . The most important safety specification of a P program is that every event dequeued by a machine is handled; otherwise, the P runtime throws an \"UnhandledEvent\" exception. The PingPong program satisfies this specification, since the Server machine handles the PING event, and the Client machine handles the PONG event in every state where an event dequeue is possible. In order to terminate a state machine cleanly, there is a special halt event. Termination of a machine due to an unhandled halt event is a valid behavior and does not throw the UnhandledEvent exception. Therefore, a machine can be halted by queuing a halt event to it. From the point of view of formal operational semantics, a halted machine is fully receptive and consumes any event that is sent to it. The P runtime implements this semantics efficiently by cleaning up resources allocated with the halting machine and recording that the machine has halted. An event sent to a halted machine is simply dropped. A halted machine cannot be restarted; it remains halted forever.","title":"Client Server"},{"location":"tutorial/espressomachine/","text":"","title":"Espressomachine"},{"location":"tutorial/failuredetector/","text":"","title":"Failuredetector"},{"location":"tutorial/paxos/","text":"","title":"Paxos Made Simple"},{"location":"tutorial/twophasecommit/","text":"","title":"Two Phase Commit"}]}