{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"P P is a state machine based programming language for modeling and specifying complex distributed systems. P allows the programmer to specify the system as a collection of interacting state machines, which communicate with each other using events. P unifies modeling, programming, and testing into one activity for the programmer. Not only can a P program be compiled into executable code, but it can also be systematically tested using Model Checking. P is currently being used extensively inside Amazon (AWS) for model checking complex distributed systems. P has been used to implement and validate the USB device driver stack that ships with Microsoft Windows 8 and Windows Phone. We have also used P for programming safe robotics systems.","title":"P"},{"location":"#p","text":"P is a state machine based programming language for modeling and specifying complex distributed systems. P allows the programmer to specify the system as a collection of interacting state machines, which communicate with each other using events. P unifies modeling, programming, and testing into one activity for the programmer. Not only can a P program be compiled into executable code, but it can also be systematically tested using Model Checking. P is currently being used extensively inside Amazon (AWS) for model checking complex distributed systems. P has been used to implement and validate the USB device driver stack that ships with Microsoft Windows 8 and Windows Phone. We have also used P for programming safe robotics systems.","title":"P"},{"location":"articles/","text":"Blogs P: A programming language designed for asynchrony, fault-tolerance and uncertainty Building robust USB 3.0 support Using Formal Methods to Validate OTA Protocol News TechWorld[2016] : Microsoft open-sources P language for IoT InfoQ [2016]: Microsoft Open-Sources P Language for Safe Async Event-Driven Programming Reddit[2016] : Microsoft opensources P language","title":"Blogs and Articles"},{"location":"articles/#blogs","text":"P: A programming language designed for asynchrony, fault-tolerance and uncertainty Building robust USB 3.0 support Using Formal Methods to Validate OTA Protocol","title":"Blogs"},{"location":"articles/#news","text":"TechWorld[2016] : Microsoft open-sources P language for IoT InfoQ [2016]: Microsoft Open-Sources P Language for Safe Async Event-Driven Programming Reddit[2016] : Microsoft opensources P language","title":"News"},{"location":"casestudies/","text":"Programming Safe Robotics Systems using P We built DRONA, a software framework for distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the distributed robotics software stack ( wiki ). The C code generated from P compiler can be easily deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/ See fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram. Programming Secure Distributed Systems using P Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. We extended P to the PSec language to enable programming secure distributed systems. We leverage Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, we prevent P programmers from inadvertently leaking sensitive information while sending data securely across machines. We formally proved the security properties of the extended P language and used it to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here .","title":"Case Studies"},{"location":"casestudies/#programming-safe-robotics-systems-using-p","text":"We built DRONA, a software framework for distributed mobile robotics systems. DRONA uses P language for implementing and model-checking the distributed robotics software stack ( wiki ). The C code generated from P compiler can be easily deployed on Robot Operating System (ROS). More details about the DRONA framework and simulation videos are available here: https://drona-org.github.io/Drona/ See fun demo video using P to control a quadrocopter and make sense of the MavLink stream, all visualized in a live DGML diagram.","title":"Programming Safe Robotics Systems using P"},{"location":"casestudies/#programming-secure-distributed-systems-using-p","text":"Programming secure distributed systems that have a formal guarantee of no information leakage is challenging. We extended P to the PSec language to enable programming secure distributed systems. We leverage Intel SGX enclaves to ensure that the security guarantees provided by the P language are enforced at runtime. By combining information flow control with hardware enclaves, we prevent P programmers from inadvertently leaking sensitive information while sending data securely across machines. We formally proved the security properties of the extended P language and used it to program several real-world examples, including a One Time Passcode application and a Secure Electronic Voting System. Details about the PSec framework can be found here .","title":"Programming Secure Distributed Systems using P"},{"location":"faq/","text":"","title":"FAQ"},{"location":"howdoesitwork/","text":"","title":"How does P work"},{"location":"publications/","text":"Selected Publications Compositional Programming and Testing of Dynamic Distributed Systems . Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia. International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018. DRONA: A Framework for Safe Distributed Mobile Robotics . Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia. In Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS), 2017. Systematic Testing of Asynchronous Reactive Systems . Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia. In Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2015). P: Safe asynchronous event-driven programming . Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien Zufferey. In Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2013.","title":"Publications"},{"location":"publications/#selected-publications","text":"Compositional Programming and Testing of Dynamic Distributed Systems . Ankush Desai, Amar Phanishayee, Shaz Qadeer, and Sanjit Seshia. International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2018. DRONA: A Framework for Safe Distributed Mobile Robotics . Ankush Desai, Indranil Saha, Jianqiao Yang, Shaz Qadeer, and Sanjit A. Seshia. In Proceedings of the 8th ACM/IEEE International Conference on Cyber-Physical Systems (ICCPS), 2017. Systematic Testing of Asynchronous Reactive Systems . Ankush Desai, Shaz Qadeer, and Sanjit A. Seshia. In Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2015). P: Safe asynchronous event-driven programming . Ankush Desai, Vivek Gupta, Ethan Jackson, Shaz Qadeer, Sriram Rajamani, and Damien Zufferey. In Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 2013.","title":"Selected Publications"},{"location":"tutsoutline/","text":"","title":"Outline"},{"location":"videos/","text":"Overview on the Microsoft Tech Minutes Series Learn how Coyote can automatically find and reproduce deep concurrency bugs in your code, helping increase the reliability of your service, in this high-level overview of Coyote: Introductory tutorial on P This YouTube video will show you how to write your first concurrency unit test and use Coyote to test your unmodified task-based C# code: Tech Talks and Presentations Pi-Week Talk:","title":"Videos"},{"location":"videos/#overview-on-the-microsoft-tech-minutes-series","text":"Learn how Coyote can automatically find and reproduce deep concurrency bugs in your code, helping increase the reliability of your service, in this high-level overview of Coyote:","title":"Overview on the Microsoft Tech Minutes Series"},{"location":"videos/#introductory-tutorial-on-p","text":"This YouTube video will show you how to write your first concurrency unit test and use Coyote to test your unmodified task-based C# code:","title":"Introductory tutorial on P"},{"location":"videos/#tech-talks-and-presentations","text":"Pi-Week Talk:","title":"Tech Talks and Presentations"},{"location":"getstarted/build/","text":"Build from source If you plan to contribute a Pull Request to P then you need to be able to build the source code and run the tests. Prerequisites .NET 3.1 SDK Java JRE 1 Optional: For developing P programs: IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. For editing C# code (P compiler): Rider or Visual Studio for Mac or Visual Studio 2019 . For editing Java code (P Java runtime): IntelliJ IDEA Building the P project Clone the P repo . On Windows 1 2 cd Bld ./build.ps1 on MacOS or Linux 1 2 cd Bld ./build.sh Running the tests You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the P.sln . 1 2 dotnet build --configuration Release dotnet test --configuration Release P compiler uses ANTLR parser generator that using Java. \u21a9","title":"Building from Source"},{"location":"getstarted/build/#build-from-source","text":"If you plan to contribute a Pull Request to P then you need to be able to build the source code and run the tests.","title":"Build from source"},{"location":"getstarted/build/#prerequisites","text":".NET 3.1 SDK Java JRE 1 Optional: For developing P programs: IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. For editing C# code (P compiler): Rider or Visual Studio for Mac or Visual Studio 2019 . For editing Java code (P Java runtime): IntelliJ IDEA","title":"Prerequisites"},{"location":"getstarted/build/#building-the-p-project","text":"Clone the P repo . On Windows 1 2 cd Bld ./build.ps1 on MacOS or Linux 1 2 cd Bld ./build.sh","title":"Building the P project"},{"location":"getstarted/build/#running-the-tests","text":"You can run the following command to build and run the test regressions for P Compiler. Make sure you are in the root directory of the clone repo that has the P.sln . 1 2 dotnet build --configuration Release dotnet test --configuration Release P compiler uses ANTLR parser generator that using Java. \u21a9","title":"Running the tests"},{"location":"getstarted/clientserver/","text":"A P program is a collection of event and machine declarations. Here is a basic P program containing a Client machine and a Server machine communicating with each other via Ping and Pong events. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // PingPong.p event PING assert 1: machine; event PONG assert 1; event SUCCESS; main machine Client { var server: machine; start state Init { entry { server = new Server(); raise SUCCESS; } on SUCCESS goto SendPing; } state SendPing { entry { send server, PING, this; raise SUCCESS; } on SUCCESS goto WaitPong; } state WaitPong { on PONG goto SendPing; } } machine Server { start state WaitPing { on PING goto SendPong; } state SendPong { entry (payload: machine) { send payload, PONG; raise SUCCESS; } on SUCCESS goto WaitPing; } } We now take a closer look at the event and machine declarations in this program. The declaration of event PING indicates that it is accompanied with a data value of machine type. The machine type contains the addresses of all dynamically-created P machines. This declaration also indicates that at most one instance of the PING event may be present in the input queue of any machine. A machine declaration contains a collection of variable and state declarations. For example, the machine Client has a variable server and three states, Init , SendPing , and WaitPong , declared inside it. The storage for the server variable is local to a particular instance of the Client machine. State Init is declared to be the start state to indicate that an instance of Client begins executing by entering the Init state. There can be many different declarations inside a state. A code block indicated by entry { ... } is executed when the state is entered. Similarly, a code block indicated by exit { ... } (not used in our example) is executed when the state is exited. Other than these two declarations, all other declarations inside a state are related to event handling. The declaration on SUCCESS goto SendPing in state Init is an example of such a declaration indicating that the SUCCESS event must be handled by moving to state SendPing . Different states can choose to handle a particular event differently. For example, state Init handles SUCCESS by moving to state SendPing but state SendPing handled SUCCESS by moving to state WaitPong . Next, we look at the contents of the entry code block in state Init of machine Client . This code block has two statements. The first statement creates an instance of the Server machine and stores the address of this instance in variable server . The second statement raises an event SUCCESS which causes control to exit Init and enter SendPing . In P, when a machine sends an event to another machine (or itself), the event is enqueued in the target machine's input queue. However, a raised event does not go through the queue; rather it terminates execution of the enclosing code block and is handled immediately. The entry code block in state SendPing shows an example of the \"send\" statement for sending a PING event to the machine whose address is stored in the variable server. The keyword this evaluates to the address of the machine executing the current statement. Finally, the entry code block in state SendPong of machine Server shows that the data value associated with a received event can be retrieved through a parameter of the apppriate type to the event handler. In this code block, the payload parameter evaluates to the data attached to the PING event whose handling caused control to enter SendPong . This data value is the address of the instance of the Client machine that sent the PING event. Similarly, a parameter can be used to retrieve the argument to the constructor of a freshly-created machine when it starts execution in the entry block of its start state. The attentive reader might be wondering how the PingPong program begins execution. The machine Client is annotated with main to indicate that program execution begins with a single instance of Client entering state Init . Let us call this Client instance X. X creates an instance of Server and raises SUCCESS to enter state SendPing . Let us call this Server instance Y; it begins execution in state WaitPing of Server . From this point on, X and Y exchange PING and PONG messages, where X cycles between SendPing and WaitPong and Y cycles between WaitPing and SendPong . The most important safety specification of a P program is that every event dequeued by a machine is handled; otherwise, the P runtime throws an \"UnhandledEvent\" exception. The PingPong program satisfies this specification, since the Server machine handles the PING event, and the Client machine handles the PONG event in every state where an event dequeue is possible. In order to terminate a state machine cleanly, there is a special halt event. Termination of a machine due to an unhandled halt event is a valid behavior and does not throw the UnhandledEvent exception. Therefore, a machine can be halted by queuing a halt event to it. From the point of view of formal operational semantics, a halted machine is fully receptive and consumes any event that is sent to it. The P runtime implements this semantics efficiently by cleaning up resources allocated with the halting machine and recording that the machine has halted. An event sent to a halted machine is simply dropped. A halted machine cannot be restarted; it remains halted forever.","title":"Simple client server application using P"},{"location":"getstarted/install/","text":"Installing P Tool Chain The P compiler is a NuGet library and works on .NET Core which means it can be used on Windows, Linux and macOS. Prerequisites .NET 3.1 SDK Java JRE 1 Optional: For developing P programs: IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. For debugging generated C# code: Rider or Visual Studio for Mac or Visual Studio 2019 . For debugging generated Java code: IntelliJ IDEA Nuget Packages Install P Compiler Install Coyote Version 1.0.5 Installing the P compiler Install the dotnet tool named P using the following command: 1 dotnet tool install --global P Now you can run the P compiler without having to build P from source. Type pc -h to see if it is working. You can update the version of P tool by running the following command: 1 dotnet tool update --global P You can remove the global P tool by running the following command: 1 dotnet tool uninstall --global P Installing the P Checker The current P concurrency checker depends on Coyote (previously P# ) Install the Coyote version 1.0.5 using the following command: 1 dotnet tool install --global Microsoft.Coyote.CLI --version 1 .0.5 Now you can run coyote to check the correctness of P programs. Type coyote --help to see if it is working. On MacOS or Linux We recommend that you add the following alias to the bash profile ( ~/.bash_profile ) so that you can invoke the P checker (pmc) from the commandline. Add the following line to the ~/.bash_profile . 1 alias pmc = 'coyote test' On Windows We recommend that you add the following to the Microsoft.PowerShell_profile normally found in D:\\Users\\<username>\\Documents\\WindowsPowerShell 1 function pmc { coyote test $args } Troubleshooting [Error] pc or coyote command not found after installation After installation, run which pc (or which coyote ) and it should show: 1 2 which pc /Users/<user>/.dotnet/tools/pc If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell. Using the P tool Great! You are all set to compile and test your first P program. To learn how to use the P tool chain read here . P compiler uses ANTLR parser generator that using Java. \u21a9","title":"Installing P"},{"location":"getstarted/install/#installing-p-tool-chain","text":"The P compiler is a NuGet library and works on .NET Core which means it can be used on Windows, Linux and macOS.","title":"Installing P Tool Chain"},{"location":"getstarted/install/#prerequisites","text":".NET 3.1 SDK Java JRE 1 Optional: For developing P programs: IntelliJ IDEA as we support basic P syntax highlighting for IntelliJ. For debugging generated C# code: Rider or Visual Studio for Mac or Visual Studio 2019 . For debugging generated Java code: IntelliJ IDEA","title":"Prerequisites"},{"location":"getstarted/install/#nuget-packages","text":"Install P Compiler Install Coyote Version 1.0.5","title":"Nuget Packages"},{"location":"getstarted/install/#installing-the-p-compiler","text":"Install the dotnet tool named P using the following command: 1 dotnet tool install --global P Now you can run the P compiler without having to build P from source. Type pc -h to see if it is working. You can update the version of P tool by running the following command: 1 dotnet tool update --global P You can remove the global P tool by running the following command: 1 dotnet tool uninstall --global P","title":"Installing the P compiler"},{"location":"getstarted/install/#installing-the-p-checker","text":"The current P concurrency checker depends on Coyote (previously P# ) Install the Coyote version 1.0.5 using the following command: 1 dotnet tool install --global Microsoft.Coyote.CLI --version 1 .0.5 Now you can run coyote to check the correctness of P programs. Type coyote --help to see if it is working. On MacOS or Linux We recommend that you add the following alias to the bash profile ( ~/.bash_profile ) so that you can invoke the P checker (pmc) from the commandline. Add the following line to the ~/.bash_profile . 1 alias pmc = 'coyote test' On Windows We recommend that you add the following to the Microsoft.PowerShell_profile normally found in D:\\Users\\<username>\\Documents\\WindowsPowerShell 1 function pmc { coyote test $args }","title":"Installing the P Checker"},{"location":"getstarted/install/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"getstarted/install/#error-pc-or-coyote-command-not-found-after-installation","text":"After installation, run which pc (or which coyote ) and it should show: 1 2 which pc /Users/<user>/.dotnet/tools/pc If not, add $HOME/.dotnet/tools to $PATH in your .bash_profile (or equivalent) and try again after restarting the shell.","title":"[Error] pc or coyote command not found after installation"},{"location":"getstarted/install/#using-the-p-tool","text":"Great! You are all set to compile and test your first P program. To learn how to use the P tool chain read here . P compiler uses ANTLR parser generator that using Java. \u21a9","title":"Using the P tool"},{"location":"getstarted/syntaxhighlight/","text":"Syntax Highlighting for P in IntelliJ Download the zip here and import it as settings into IntelliJ ( check here ). It will add highlighting for *.p files using FileTypes settings. Syntax Highlighting for P in Sublime [Deprecated] We used to support syntax highlighting for Sublime editor but is no longer maintained and hence may not support latest P language features. (But if you are die hard sublime fan check out: Sublime Plugin for P (.p) files ). Troubleshooting If you face any issues getting the syntax highlighting working, please create an issue on the P Github Repository.","title":"Syntax Highlighting for P"},{"location":"getstarted/syntaxhighlight/#syntax-highlighting-for-p-in-intellij","text":"Download the zip here and import it as settings into IntelliJ ( check here ). It will add highlighting for *.p files using FileTypes settings.","title":"Syntax Highlighting for P in IntelliJ"},{"location":"getstarted/syntaxhighlight/#syntax-highlighting-for-p-in-sublime","text":"[Deprecated] We used to support syntax highlighting for Sublime editor but is no longer maintained and hence may not support latest P language features. (But if you are die hard sublime fan check out: Sublime Plugin for P (.p) files ).","title":"Syntax Highlighting for P in Sublime"},{"location":"getstarted/syntaxhighlight/#troubleshooting","text":"If you face any issues getting the syntax highlighting working, please create an issue on the P Github Repository.","title":"Troubleshooting"},{"location":"howtoguides/importanceliveness/","text":"","title":"Importance of Liveness Specifications"},{"location":"howtoguides/modelbasedtesting/","text":"","title":"Model based testing of implementation"},{"location":"howtoguides/sharedmemory/","text":"","title":"Modeling Shared Memory Concurrency"},{"location":"manual/events/","text":"","title":"P Events"},{"location":"manual/functions/","text":"","title":"P Foreign Interface"},{"location":"manual/monitors/","text":"","title":"P Monitors"},{"location":"manual/statemachines/","text":"","title":"P State Machines"},{"location":"tutorial/clientserver/","text":"","title":"Client Server"},{"location":"tutorial/paxos/","text":"","title":"Paxos Made Simple"},{"location":"tutorial/twophasecommit/","text":"","title":"Two Phase Commit"}]}